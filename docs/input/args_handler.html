<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sql_code_analyzer.input.args_handler API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sql_code_analyzer.input.args_handler</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import argparse
import os
from pathlib import Path
from sys import stdin
import re

from sql_code_analyzer.input.database_server.base import database_connection_handler
from sql_code_analyzer.input.database_server.config import DBConfig
from sql_code_analyzer.output import enums
from sql_code_analyzer.output.reporter.base import OutputType, Reporter
from sql_code_analyzer.output.reporter.program_reporter import ProgramReporter
from sql_code_analyzer.output.terminator.base import Terminator
from sql_code_analyzer.tools.path import get_program_root_path, get_absolute_path, verify_path_access, \
    verify_path_exists, create_path_if_not_exists, ProgramPathConfig
from test_cases.sqlglot.tester import run_tests


class CArgs:
    &#34;&#34;&#34;
    Instance from CArgs class contains all data comes as input of program.

    Provides:
        Program arguments parsing and processing and interface to obtain these data.
        Help a message where parameters are described in detail.
        Features retrieve SQL input from file/standard input/database server.
        Possibility to create configuration template for proper database connection.
        Create statements from raw SQL file

    &#34;&#34;&#34;

    def __init__(self):

        self.show_dll = False
        self.database_statements = []
        self.dialect: str = &#34;&#34;
        self.file: str | Path = &#34;&#34;
        self.tests: bool = False
        self.raw_sql: str = &#34;&#34;
        self.statements: list = []

        self.rules_path: str = &#34;&#34;
        self.include_folders: list = []
        self.exclude_folders: list = []

        self.serialization_file: str | None = None
        self.serialization_path: str | None = None
        self.deserialization_file: str | None = None
        self.deserialization_path: str | None = None

        self.connection_file_create: bool = False
        self.connection_file_section: str | None = None
        self.connection_file: str | None = None
        self.connection_file_path: str | None = None

        self.db_config = None
        self.report_output_silent = None
        self.report_output_file = None

        args = parse_args()

        # If file path sets, then verify its correctness
        verify_file_path(self, args)

        ################################
        #        PROGRAM OUTPUT
        ################################
        ProgramReporter.verbose = args.verbose

        if self.report_output_silent and args.verbose:
            ProgramReporter.show_warning_message(
                message=&#34;The output on the program is set to silent(--report-output-silent). &#34;
                        &#34;Using the verbose parameter does not make sense.&#34;
            )

        if self.report_output_silent and self.report_output_file:
            ProgramReporter.show_error_message(
                message=&#34;Parameters --report-output-silent and --report-output-file are mutually exclusive.&#34;
            )

        if self.report_output_silent:
            Reporter.report_output = OutputType.Silent

        if self.report_output_file:

            # If an output file path is None, then use the default one
            # This also creates necessary folders!
            # if self.report_output_file is None:
            #     self.report_output_file = create_path_if_not_exists(
            #                 path=get_program_default_output_path() / self.report_output_file)

            Reporter.set_output_file(
                path=ProgramPathConfig.get_program_output_path() / self.report_output_file
            )

            # Reporter.report_output = OutputType.File

            # Reporter.report_output_file = get_program_default_output_path() / self.report_output_file
            # verify_path_exists(path=ProgramReporter.report_output_file)
            # verify_path_access(path=ProgramReporter.report_output_file)

        ################################
        #            TESTS
        ################################
        # Run tests
        if self.tests:
            run_tests()
            Terminator.exit(enums.ExitWith.Success)

        ################################
        #           DATABASE
        ################################
        # Create database connection file template
        if self.connection_file_create:
            self.create_database_connection_file()
            Terminator.exit(enums.ExitWith.Success)

        if self.connection_file_path is not None and self.deserialization_file is not None:
            ProgramReporter.show_error_message(
                message=&#34;Attributes --connection_file_path and --deserialization-file are mutually exclusive.\n&#34;
                        &#34;It possible to load memory representation either from serialized file or database server.&#34;
            )

        # If is section set, then its activates a database connection feature
        if self.connection_file_section is not None:

            # If a connection file path is None, then use the default one
            # This also creates necessary folders!
            if self.connection_file_path is None:
                self.connection_file_path = ProgramPathConfig.get_database_configuration_path()

            # load from an existing database
            self.db_config = DBConfig(path=get_absolute_path(path=self.connection_file_path),
                                      file=self.connection_file,
                                      option=self.connection_file_section)

            database_connection_handler(args=self)

        ################################
        #            INPUT
        ################################
        # Get SQL from file or standard input
        if self.file:
            # load sql from file
            with open(self.file, &#39;r&#39;) as file:
                self.raw_sql = file.read()

            parse_raw_sql_to_statement(self)

        else:
            # check stdin
            print(&#34;Enter target SQL:&#34;)
            self.raw_sql = stdin.read()
            parse_raw_sql_to_statement(self)

        ################################
        #         SERIALIZATION
        ################################
        # If serialization file is set, the then program provides serialization
        if self.serialization_file is not None:

            # If a serialization path is None, then use the default one
            # This also creates necessary folders!
            if self.serialization_path is None:
                self.serialization_path = create_path_if_not_exists(
                            path=ProgramPathConfig.get_program_backup_path())

            # Make sure the path is absolute
            self.serialization_path = get_absolute_path(path=self.serialization_path)

            # Verify path
            verify_path_exists(path=self.serialization_path)
            verify_path_access(path=self.serialization_path)

        # If serialization file is set, the then program provides deserialization
        if self.deserialization_file is not None:

            # If a deserialization path is None, then use the default one
            # This also creates necessary folders!
            if self.deserialization_path is None:
                self.deserialization_path = create_path_if_not_exists(
                    path=ProgramPathConfig.get_program_backup_path())

            # Make sure the path is absolute
            self.deserialization_path = get_absolute_path(path=self.deserialization_path)

            # Verify path
            verify_path_exists(path=self.deserialization_path / self.deserialization_file)
            verify_path_access(path=self.deserialization_path / self.deserialization_file)

        ################################
        #            RULES
        ################################
        # If a rule path is not default, then process the user-defined path
        if self.rules_path != os.path.join(get_program_root_path(), &#34;checker&#34;, &#34;rules&#34;):

            # Make sure the path is absolute
            self.rules_path = get_absolute_path(path=self.rules_path)

            # Verify path
            verify_path_exists(path=self.rules_path)
            verify_path_access(path=self.rules_path)

    def update_parameters(self, args: argparse) -&gt; None:
        &#34;&#34;&#34;
        Dynamically creates/updates self object properties
        :param args: Data that need to be saved to self-object
        :return: None
        &#34;&#34;&#34;

        for argument, value in vars(args).items():
            setattr(self, argument, value)

    @staticmethod
    def create_database_connection_file() -&gt; None:
        &#34;&#34;&#34;
        Create a template file as an example for proper database connection.
        :return: None
        &#34;&#34;&#34;

        root_path = create_path_if_not_exists(
            path=ProgramPathConfig.get_database_configuration_path()
        )

        f = open(os.path.join(root_path, &#34;db_connection.cfg&#34;), &#34;w&#34;)
        f.write(
            &#34;##################################################################\n&#34;
            &#34;#############    THIS FILE CONTAINS CONFIGURATION    #############\n&#34;
            &#34;##################################################################\n&#34;
            &#34;# \n&#34;
            &#34;# This file is a configuration template for connecting the program\n&#34;.upper() +
            &#34;# to an existing database. Please replace the words containing\n&#34;.upper() +
            &#34;# the underscore with the data that corresponds to connecting \n&#34;.upper() +
            &#34;# the client to the database.\n&#34;.upper() +
            &#34;# \n&#34;
            &#34;# In this file you can create comments using the grid wildcard (#)\n&#34;.upper() +
            &#34;# which will cause all content after it on a given line to be \n&#34;.upper() +
            &#34;# ignored by the program.\n&#34;.upper() +
            &#34;#\n&#34;            
            &#34;# Here is an example of use:\n&#34;
            &#34;#\n&#34;
            &#34;# DIALECT = oracle # enter database dialect\n&#34;
            &#34;# USERNAME = MyName  # enter your username\n&#34;
            &#34;# PASSWORD = An4q6Db458d1w2r8  # enter your password\n&#34;
            &#34;# HOST = localhost  # enter host url (for example localhost)\n&#34;
            &#34;# PORT = 1521  # enter the port number\n&#34;
            &#34;# SERVICE =  orcl.mshome.net  # enter the database service name\n&#34;
            &#34;\n&#34;
            &#34;\n&#34;
            &#34;DIALECT = target_dialect # enter database dialect\n&#34;
            &#34;USERNAME = your_username  # enter your username\n&#34;
            &#34;PASSWORD = your_password  # enter your password\n&#34;
            &#34;HOST = target_host  # enter host url (for example localhost)\n&#34;
            &#34;PORT = target_port_number  # enter the port number\n&#34;
            &#34;SERVICE =  target_service  # enter the database service name\n&#34;
        )
        f.close()
        
        print(&#34;The configuration template has been successfully created.\n&#34;
              f&#34;Path: {root_path}\n&#34;
              f&#34;File: db_connection.cfg&#34;)


def parse_raw_sql_to_statement(args_data) -&gt; None:
    &#34;&#34;&#34;
    Implements algorithm to detect a statement from raw input file.
    Statements are stored as items in a list.
    If appropriate, stand alone comments blocks are deleted.
    Statements are detected by statement&#39;s terminating character &#34;;&#34;

    :param args_data: Arguments data
    :return: None
    &#34;&#34;&#34;

    raw = args_data.raw_sql

    # Delete everything between /* and */ but keeps newlines
    raw = re.sub(r&#39;/\*.*?\*/&#39;, lambda x: x.group().count(&#39;\n&#39;) * &#39;\n&#39;, raw, flags=re.DOTALL)

    # Delete everything between -- and newline but keeps newline
    raw = re.sub(r&#39;--.*?\n&#39;, &#39;\n&#39;, raw)

    lines = raw.split(&#34;\n&#34;)
    result = &#34;&#34;
    for i, line in enumerate(lines):
        result += line + &#34; -- &#34; + str(i + 1) + &#34;\n&#34;

    lines = result.split(&#34;\n&#34;)
    result = []
    temp = &#34;&#34;
    for line in lines:
        if &#34;;&#34; in line:
            temp += line + &#34;\n&#34;
            result.append(temp)
            temp = &#34;&#34;
        else:
            temp += line + &#34;\n&#34;

    for index, statement in enumerate(result):
        lines = statement.split(&#34;\n&#34;)
        tmp = &#34;&#34;
        for line in lines:
            if line.lstrip().find(&#34;--&#34;) &gt; 0:
                tmp += line + &#34;\n&#34;
        result[index] = tmp

    lines = result
    result = []
    for line in lines:
        index = int(line.split(&#34;--&#34;)[1].split(&#34;\n&#34;)[0])
        result.append((line, index))

    args_data.statements += result


def parse_args() -&gt; argparse:
    &#34;&#34;&#34;
    Parse program arguments using Argparse library
    :return: Argparse object
    &#34;&#34;&#34;

    parser = argparse.ArgumentParser()
    parser.add_argument(&#34;-t&#34;, &#34;--tests&#34;,
                        action=&#39;store_true&#39;,
                        required=False,
                        help=&#34;Run tests.&#34;,
                        default=None)

    # TODO Implemetovať dialekt Oracle/MSSQL
    parser.add_argument(&#34;-d&#34;, &#34;--dialect&#34;,
                        metavar=&#34;&#34;,
                        required=False,
                        help=&#34;Expect target dialect.&#34;,
                        default=None)

    parser.add_argument(&#34;-f&#34;, &#34;--file&#34;,
                        type=str,
                        metavar=&#34;&#34;,
                        required=False,
                        help=&#34;Expect file with target SQL, &#34;
                             &#34;if this parameter is not present &#34;
                             &#34;then the program expects it on standard input.&#34;,
                        default=None)

    ############################
    #         DATABASE
    ############################
    parser.add_argument(&#34;-cfc&#34;, &#34;--connection-file-create&#34;,
                        action=&#39;store_true&#39;,
                        required=False,
                        help=&#34;Create template file for database connection.&#34;,
                        default=None)

    # Activates database-connection feature
    parser.add_argument(&#34;-cfo&#34;, &#34;--connection-file-section&#34;,
                        required=False,
                        type=str,
                        help=&#34;Specify section in config file. Config file may contain several configurations &#34;
                             &#34;which can be selected by this parameter.&#34;,
                        default=None)

    parser.add_argument(&#34;-cf&#34;, &#34;--connection-file&#34;,
                        required=False,
                        type=str,
                        help=&#34;Name of file where is expected to be a data for database connection.&#34;,
                        default=&#34;db_connection.cfg&#34;)

    parser.add_argument(&#34;-cfp&#34;, &#34;--connection-file-path&#34;,
                        required=False,
                        type=str,
                        help=&#34;Path where is expected to be a file with data for database connection.&#34;,
                        default=None)

    ############################
    #       SERIALIZATION
    ############################
    # Activates serialization feature
    parser.add_argument(&#34;-sf&#34;, &#34;--serialization-file&#34;,
                        required=False,
                        type=str,
                        help=&#34;If set, the program will provide a backup representation of the results in memory &#34;
                             &#34;to a file with the specified name and save them to selected/default path.&#34;,
                        default=None)

    # The default value will be set later
    # This avoids unnecessary directory creation for output.
    parser.add_argument(&#34;-sp&#34;, &#34;--serialization-path&#34;,
                        required=False,
                        type=str,
                        help=&#34;If specified, then the serialization path will be changed to the specified path.&#34;,
                        default=None)

    # Activates deserialization feature
    parser.add_argument(&#34;-df&#34;, &#34;--deserialization-file&#34;,
                        required=False,
                        type=str,
                        help=&#34;If set, the program reads the memory representation and initializes it &#34;
                             &#34;from a file with the specified name on the selected/default path.&#34;,
                        default=None)

    # The default value will be set later
    # This avoids unnecessary directory creation for output.
    parser.add_argument(&#34;-dp&#34;, &#34;--deserialization-path&#34;,
                        required=False,
                        type=str,
                        help=&#34;If specified, then the deserialization path will be changed to the specified path.&#34;,
                        default=None)

    ############################
    #           RULES
    ############################
    parser.add_argument(&#34;-rp&#34;, &#34;--rules-path&#34;,
                        type=str,
                        required=False,
                        help=&#34;Specify folder with rules. If not set then default is &#34;
                             &#34;..\\sql_code_analyzer\\checker\\rules&#34;,
                        default=os.path.join(get_program_root_path(), &#34;checker&#34;, &#34;rules&#34;))

    parser.add_argument(&#34;-if&#34;, &#34;--include-folders&#34;,
                        nargs=&#39;+&#39;,
                        type=str,
                        required=False,
                        help=&#34;Specify folder names with rules which should be included in rules path. &#34;
                             &#34;Parameters --include-folders and --exclude-folders &#34;
                             &#34;are mutually exclusive and only one of them can be set. &#34;
                             &#34;Accepted format: -if folder1 folder2 folderN&#34;,
                        default=[])

    parser.add_argument(&#34;-ef&#34;, &#34;--exclude-folders&#34;,
                        nargs=&#39;+&#39;,
                        type=str,
                        required=False,
                        help=&#34;Specify folder names with rules which should NOT be included in rules path. &#34;
                             &#34;Parameters --include-folders and --exclude-folders &#34;
                             &#34;are mutually exclusive and only one of them can be set. &#34;
                             &#34;Accepted format: -ef folder1 folder2 folderN&#34;,
                        default=[])

    ############################
    #          REPORT
    ############################
    parser.add_argument(&#34;-ros&#34;, &#34;--report-output-silent&#34;,
                        action=&#39;store_true&#39;,
                        required=False,
                        help=&#34;If set, program will no store reports. &#34;
                             &#34;Mutually exclusive with parameter --report-output-file&#34;,
                        default=None)

    parser.add_argument(&#34;-rof&#34;, &#34;--report-output-file&#34;,
                        type=str,
                        metavar=&#34;&#34;,
                        required=False,
                        help=&#34;If set, expects path where program will store reports.&#34;
                             &#34;&#34;
                             &#34;Mutually exclusive with parameter --report-output-silent&#34;,
                        default=None)

    parser.add_argument(&#34;-v&#34;, &#34;--verbose&#34;,
                        action=&#39;count&#39;,
                        required=False,
                        help=&#34;If set, program show information messages on standard input.&#34;,
                        default=0)

    args = parser.parse_args()
    return args


def verify_file_path(self, args: argparse) -&gt; None:
    &#34;&#34;&#34;
    Process and verify if the file exists.
    The arguments of the program need to be verified before they are used.
    If the user makes a mistake and sets a path that is not correct,
    for example, it is not a file, the program will detect this
    and give the user the opportunity to correct the path
    or choose to exit the program.

    :return: None
    &#34;&#34;&#34;

    err_user_answer = False

    if args.file is not None:

        self.file = get_absolute_path(path=args.file)
        while 1:
            if not self.file.is_file():

                if err_user_answer:
                    user_answer = input(&#34;\nPlease answer only [yes/no] or in short way [y/n]\n&#34;
                                        &#34;Do you want set another path? [y/n]\n&#34;)
                else:
                    user_answer = input(&#34;\nFile not exits!\n&#34;
                                        &#34;Do you want set another path? [y/n]\n&#34;)

                if user_answer.lower() == &#34;n&#34; or user_answer.lower() == &#34;no&#34;:
                    Terminator.exit(enums.ExitWith.Success)

                elif user_answer.lower() == &#34;y&#34; or user_answer.lower() == &#34;yes&#34;:
                    args.file = input(&#34;Write down new path:\n&#34;)
                    err_user_answer = False
                    continue

                else:
                    err_user_answer = True

            else:
                break

    # If the file is None, then the program will be asking for SQL code through standard input

    # All args will be synchronized with &#34;self&#34; object.
    # But self.file now contains a Path version of a file path, not a string one.
    # So self.file needs to be passed to args.file otherwise self.file will be overwritten by old string input.

    args.file = self.file
    self.update_parameters(args=args)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sql_code_analyzer.input.args_handler.parse_args"><code class="name flex">
<span>def <span class="ident">parse_args</span></span>(<span>) ‑> <module 'argparse' from 'C:\\Program Files\\Python311\\Lib\\argparse.py'></span>
</code></dt>
<dd>
<div class="desc"><p>Parse program arguments using Argparse library
:return: Argparse object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_args() -&gt; argparse:
    &#34;&#34;&#34;
    Parse program arguments using Argparse library
    :return: Argparse object
    &#34;&#34;&#34;

    parser = argparse.ArgumentParser()
    parser.add_argument(&#34;-t&#34;, &#34;--tests&#34;,
                        action=&#39;store_true&#39;,
                        required=False,
                        help=&#34;Run tests.&#34;,
                        default=None)

    # TODO Implemetovať dialekt Oracle/MSSQL
    parser.add_argument(&#34;-d&#34;, &#34;--dialect&#34;,
                        metavar=&#34;&#34;,
                        required=False,
                        help=&#34;Expect target dialect.&#34;,
                        default=None)

    parser.add_argument(&#34;-f&#34;, &#34;--file&#34;,
                        type=str,
                        metavar=&#34;&#34;,
                        required=False,
                        help=&#34;Expect file with target SQL, &#34;
                             &#34;if this parameter is not present &#34;
                             &#34;then the program expects it on standard input.&#34;,
                        default=None)

    ############################
    #         DATABASE
    ############################
    parser.add_argument(&#34;-cfc&#34;, &#34;--connection-file-create&#34;,
                        action=&#39;store_true&#39;,
                        required=False,
                        help=&#34;Create template file for database connection.&#34;,
                        default=None)

    # Activates database-connection feature
    parser.add_argument(&#34;-cfo&#34;, &#34;--connection-file-section&#34;,
                        required=False,
                        type=str,
                        help=&#34;Specify section in config file. Config file may contain several configurations &#34;
                             &#34;which can be selected by this parameter.&#34;,
                        default=None)

    parser.add_argument(&#34;-cf&#34;, &#34;--connection-file&#34;,
                        required=False,
                        type=str,
                        help=&#34;Name of file where is expected to be a data for database connection.&#34;,
                        default=&#34;db_connection.cfg&#34;)

    parser.add_argument(&#34;-cfp&#34;, &#34;--connection-file-path&#34;,
                        required=False,
                        type=str,
                        help=&#34;Path where is expected to be a file with data for database connection.&#34;,
                        default=None)

    ############################
    #       SERIALIZATION
    ############################
    # Activates serialization feature
    parser.add_argument(&#34;-sf&#34;, &#34;--serialization-file&#34;,
                        required=False,
                        type=str,
                        help=&#34;If set, the program will provide a backup representation of the results in memory &#34;
                             &#34;to a file with the specified name and save them to selected/default path.&#34;,
                        default=None)

    # The default value will be set later
    # This avoids unnecessary directory creation for output.
    parser.add_argument(&#34;-sp&#34;, &#34;--serialization-path&#34;,
                        required=False,
                        type=str,
                        help=&#34;If specified, then the serialization path will be changed to the specified path.&#34;,
                        default=None)

    # Activates deserialization feature
    parser.add_argument(&#34;-df&#34;, &#34;--deserialization-file&#34;,
                        required=False,
                        type=str,
                        help=&#34;If set, the program reads the memory representation and initializes it &#34;
                             &#34;from a file with the specified name on the selected/default path.&#34;,
                        default=None)

    # The default value will be set later
    # This avoids unnecessary directory creation for output.
    parser.add_argument(&#34;-dp&#34;, &#34;--deserialization-path&#34;,
                        required=False,
                        type=str,
                        help=&#34;If specified, then the deserialization path will be changed to the specified path.&#34;,
                        default=None)

    ############################
    #           RULES
    ############################
    parser.add_argument(&#34;-rp&#34;, &#34;--rules-path&#34;,
                        type=str,
                        required=False,
                        help=&#34;Specify folder with rules. If not set then default is &#34;
                             &#34;..\\sql_code_analyzer\\checker\\rules&#34;,
                        default=os.path.join(get_program_root_path(), &#34;checker&#34;, &#34;rules&#34;))

    parser.add_argument(&#34;-if&#34;, &#34;--include-folders&#34;,
                        nargs=&#39;+&#39;,
                        type=str,
                        required=False,
                        help=&#34;Specify folder names with rules which should be included in rules path. &#34;
                             &#34;Parameters --include-folders and --exclude-folders &#34;
                             &#34;are mutually exclusive and only one of them can be set. &#34;
                             &#34;Accepted format: -if folder1 folder2 folderN&#34;,
                        default=[])

    parser.add_argument(&#34;-ef&#34;, &#34;--exclude-folders&#34;,
                        nargs=&#39;+&#39;,
                        type=str,
                        required=False,
                        help=&#34;Specify folder names with rules which should NOT be included in rules path. &#34;
                             &#34;Parameters --include-folders and --exclude-folders &#34;
                             &#34;are mutually exclusive and only one of them can be set. &#34;
                             &#34;Accepted format: -ef folder1 folder2 folderN&#34;,
                        default=[])

    ############################
    #          REPORT
    ############################
    parser.add_argument(&#34;-ros&#34;, &#34;--report-output-silent&#34;,
                        action=&#39;store_true&#39;,
                        required=False,
                        help=&#34;If set, program will no store reports. &#34;
                             &#34;Mutually exclusive with parameter --report-output-file&#34;,
                        default=None)

    parser.add_argument(&#34;-rof&#34;, &#34;--report-output-file&#34;,
                        type=str,
                        metavar=&#34;&#34;,
                        required=False,
                        help=&#34;If set, expects path where program will store reports.&#34;
                             &#34;&#34;
                             &#34;Mutually exclusive with parameter --report-output-silent&#34;,
                        default=None)

    parser.add_argument(&#34;-v&#34;, &#34;--verbose&#34;,
                        action=&#39;count&#39;,
                        required=False,
                        help=&#34;If set, program show information messages on standard input.&#34;,
                        default=0)

    args = parser.parse_args()
    return args</code></pre>
</details>
</dd>
<dt id="sql_code_analyzer.input.args_handler.parse_raw_sql_to_statement"><code class="name flex">
<span>def <span class="ident">parse_raw_sql_to_statement</span></span>(<span>args_data) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Implements algorithm to detect a statement from raw input file.
Statements are stored as items in a list.
If appropriate, stand alone comments blocks are deleted.
Statements are detected by statement's terminating character ";"</p>
<p>:param args_data: Arguments data
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_raw_sql_to_statement(args_data) -&gt; None:
    &#34;&#34;&#34;
    Implements algorithm to detect a statement from raw input file.
    Statements are stored as items in a list.
    If appropriate, stand alone comments blocks are deleted.
    Statements are detected by statement&#39;s terminating character &#34;;&#34;

    :param args_data: Arguments data
    :return: None
    &#34;&#34;&#34;

    raw = args_data.raw_sql

    # Delete everything between /* and */ but keeps newlines
    raw = re.sub(r&#39;/\*.*?\*/&#39;, lambda x: x.group().count(&#39;\n&#39;) * &#39;\n&#39;, raw, flags=re.DOTALL)

    # Delete everything between -- and newline but keeps newline
    raw = re.sub(r&#39;--.*?\n&#39;, &#39;\n&#39;, raw)

    lines = raw.split(&#34;\n&#34;)
    result = &#34;&#34;
    for i, line in enumerate(lines):
        result += line + &#34; -- &#34; + str(i + 1) + &#34;\n&#34;

    lines = result.split(&#34;\n&#34;)
    result = []
    temp = &#34;&#34;
    for line in lines:
        if &#34;;&#34; in line:
            temp += line + &#34;\n&#34;
            result.append(temp)
            temp = &#34;&#34;
        else:
            temp += line + &#34;\n&#34;

    for index, statement in enumerate(result):
        lines = statement.split(&#34;\n&#34;)
        tmp = &#34;&#34;
        for line in lines:
            if line.lstrip().find(&#34;--&#34;) &gt; 0:
                tmp += line + &#34;\n&#34;
        result[index] = tmp

    lines = result
    result = []
    for line in lines:
        index = int(line.split(&#34;--&#34;)[1].split(&#34;\n&#34;)[0])
        result.append((line, index))

    args_data.statements += result</code></pre>
</details>
</dd>
<dt id="sql_code_analyzer.input.args_handler.verify_file_path"><code class="name flex">
<span>def <span class="ident">verify_file_path</span></span>(<span>self, args: <module 'argparse' from 'C:\\Program Files\\Python311\\Lib\\argparse.py'>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Process and verify if the file exists.
The arguments of the program need to be verified before they are used.
If the user makes a mistake and sets a path that is not correct,
for example, it is not a file, the program will detect this
and give the user the opportunity to correct the path
or choose to exit the program.</p>
<p>:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_file_path(self, args: argparse) -&gt; None:
    &#34;&#34;&#34;
    Process and verify if the file exists.
    The arguments of the program need to be verified before they are used.
    If the user makes a mistake and sets a path that is not correct,
    for example, it is not a file, the program will detect this
    and give the user the opportunity to correct the path
    or choose to exit the program.

    :return: None
    &#34;&#34;&#34;

    err_user_answer = False

    if args.file is not None:

        self.file = get_absolute_path(path=args.file)
        while 1:
            if not self.file.is_file():

                if err_user_answer:
                    user_answer = input(&#34;\nPlease answer only [yes/no] or in short way [y/n]\n&#34;
                                        &#34;Do you want set another path? [y/n]\n&#34;)
                else:
                    user_answer = input(&#34;\nFile not exits!\n&#34;
                                        &#34;Do you want set another path? [y/n]\n&#34;)

                if user_answer.lower() == &#34;n&#34; or user_answer.lower() == &#34;no&#34;:
                    Terminator.exit(enums.ExitWith.Success)

                elif user_answer.lower() == &#34;y&#34; or user_answer.lower() == &#34;yes&#34;:
                    args.file = input(&#34;Write down new path:\n&#34;)
                    err_user_answer = False
                    continue

                else:
                    err_user_answer = True

            else:
                break

    # If the file is None, then the program will be asking for SQL code through standard input

    # All args will be synchronized with &#34;self&#34; object.
    # But self.file now contains a Path version of a file path, not a string one.
    # So self.file needs to be passed to args.file otherwise self.file will be overwritten by old string input.

    args.file = self.file
    self.update_parameters(args=args)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sql_code_analyzer.input.args_handler.CArgs"><code class="flex name class">
<span>class <span class="ident">CArgs</span></span>
</code></dt>
<dd>
<div class="desc"><p>Instance from CArgs class contains all data comes as input of program.</p>
<h2 id="provides">Provides</h2>
<p>Program arguments parsing and processing and interface to obtain these data.
Help a message where parameters are described in detail.
Features retrieve SQL input from file/standard input/database server.
Possibility to create configuration template for proper database connection.
Create statements from raw SQL file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CArgs:
    &#34;&#34;&#34;
    Instance from CArgs class contains all data comes as input of program.

    Provides:
        Program arguments parsing and processing and interface to obtain these data.
        Help a message where parameters are described in detail.
        Features retrieve SQL input from file/standard input/database server.
        Possibility to create configuration template for proper database connection.
        Create statements from raw SQL file

    &#34;&#34;&#34;

    def __init__(self):

        self.show_dll = False
        self.database_statements = []
        self.dialect: str = &#34;&#34;
        self.file: str | Path = &#34;&#34;
        self.tests: bool = False
        self.raw_sql: str = &#34;&#34;
        self.statements: list = []

        self.rules_path: str = &#34;&#34;
        self.include_folders: list = []
        self.exclude_folders: list = []

        self.serialization_file: str | None = None
        self.serialization_path: str | None = None
        self.deserialization_file: str | None = None
        self.deserialization_path: str | None = None

        self.connection_file_create: bool = False
        self.connection_file_section: str | None = None
        self.connection_file: str | None = None
        self.connection_file_path: str | None = None

        self.db_config = None
        self.report_output_silent = None
        self.report_output_file = None

        args = parse_args()

        # If file path sets, then verify its correctness
        verify_file_path(self, args)

        ################################
        #        PROGRAM OUTPUT
        ################################
        ProgramReporter.verbose = args.verbose

        if self.report_output_silent and args.verbose:
            ProgramReporter.show_warning_message(
                message=&#34;The output on the program is set to silent(--report-output-silent). &#34;
                        &#34;Using the verbose parameter does not make sense.&#34;
            )

        if self.report_output_silent and self.report_output_file:
            ProgramReporter.show_error_message(
                message=&#34;Parameters --report-output-silent and --report-output-file are mutually exclusive.&#34;
            )

        if self.report_output_silent:
            Reporter.report_output = OutputType.Silent

        if self.report_output_file:

            # If an output file path is None, then use the default one
            # This also creates necessary folders!
            # if self.report_output_file is None:
            #     self.report_output_file = create_path_if_not_exists(
            #                 path=get_program_default_output_path() / self.report_output_file)

            Reporter.set_output_file(
                path=ProgramPathConfig.get_program_output_path() / self.report_output_file
            )

            # Reporter.report_output = OutputType.File

            # Reporter.report_output_file = get_program_default_output_path() / self.report_output_file
            # verify_path_exists(path=ProgramReporter.report_output_file)
            # verify_path_access(path=ProgramReporter.report_output_file)

        ################################
        #            TESTS
        ################################
        # Run tests
        if self.tests:
            run_tests()
            Terminator.exit(enums.ExitWith.Success)

        ################################
        #           DATABASE
        ################################
        # Create database connection file template
        if self.connection_file_create:
            self.create_database_connection_file()
            Terminator.exit(enums.ExitWith.Success)

        if self.connection_file_path is not None and self.deserialization_file is not None:
            ProgramReporter.show_error_message(
                message=&#34;Attributes --connection_file_path and --deserialization-file are mutually exclusive.\n&#34;
                        &#34;It possible to load memory representation either from serialized file or database server.&#34;
            )

        # If is section set, then its activates a database connection feature
        if self.connection_file_section is not None:

            # If a connection file path is None, then use the default one
            # This also creates necessary folders!
            if self.connection_file_path is None:
                self.connection_file_path = ProgramPathConfig.get_database_configuration_path()

            # load from an existing database
            self.db_config = DBConfig(path=get_absolute_path(path=self.connection_file_path),
                                      file=self.connection_file,
                                      option=self.connection_file_section)

            database_connection_handler(args=self)

        ################################
        #            INPUT
        ################################
        # Get SQL from file or standard input
        if self.file:
            # load sql from file
            with open(self.file, &#39;r&#39;) as file:
                self.raw_sql = file.read()

            parse_raw_sql_to_statement(self)

        else:
            # check stdin
            print(&#34;Enter target SQL:&#34;)
            self.raw_sql = stdin.read()
            parse_raw_sql_to_statement(self)

        ################################
        #         SERIALIZATION
        ################################
        # If serialization file is set, the then program provides serialization
        if self.serialization_file is not None:

            # If a serialization path is None, then use the default one
            # This also creates necessary folders!
            if self.serialization_path is None:
                self.serialization_path = create_path_if_not_exists(
                            path=ProgramPathConfig.get_program_backup_path())

            # Make sure the path is absolute
            self.serialization_path = get_absolute_path(path=self.serialization_path)

            # Verify path
            verify_path_exists(path=self.serialization_path)
            verify_path_access(path=self.serialization_path)

        # If serialization file is set, the then program provides deserialization
        if self.deserialization_file is not None:

            # If a deserialization path is None, then use the default one
            # This also creates necessary folders!
            if self.deserialization_path is None:
                self.deserialization_path = create_path_if_not_exists(
                    path=ProgramPathConfig.get_program_backup_path())

            # Make sure the path is absolute
            self.deserialization_path = get_absolute_path(path=self.deserialization_path)

            # Verify path
            verify_path_exists(path=self.deserialization_path / self.deserialization_file)
            verify_path_access(path=self.deserialization_path / self.deserialization_file)

        ################################
        #            RULES
        ################################
        # If a rule path is not default, then process the user-defined path
        if self.rules_path != os.path.join(get_program_root_path(), &#34;checker&#34;, &#34;rules&#34;):

            # Make sure the path is absolute
            self.rules_path = get_absolute_path(path=self.rules_path)

            # Verify path
            verify_path_exists(path=self.rules_path)
            verify_path_access(path=self.rules_path)

    def update_parameters(self, args: argparse) -&gt; None:
        &#34;&#34;&#34;
        Dynamically creates/updates self object properties
        :param args: Data that need to be saved to self-object
        :return: None
        &#34;&#34;&#34;

        for argument, value in vars(args).items():
            setattr(self, argument, value)

    @staticmethod
    def create_database_connection_file() -&gt; None:
        &#34;&#34;&#34;
        Create a template file as an example for proper database connection.
        :return: None
        &#34;&#34;&#34;

        root_path = create_path_if_not_exists(
            path=ProgramPathConfig.get_database_configuration_path()
        )

        f = open(os.path.join(root_path, &#34;db_connection.cfg&#34;), &#34;w&#34;)
        f.write(
            &#34;##################################################################\n&#34;
            &#34;#############    THIS FILE CONTAINS CONFIGURATION    #############\n&#34;
            &#34;##################################################################\n&#34;
            &#34;# \n&#34;
            &#34;# This file is a configuration template for connecting the program\n&#34;.upper() +
            &#34;# to an existing database. Please replace the words containing\n&#34;.upper() +
            &#34;# the underscore with the data that corresponds to connecting \n&#34;.upper() +
            &#34;# the client to the database.\n&#34;.upper() +
            &#34;# \n&#34;
            &#34;# In this file you can create comments using the grid wildcard (#)\n&#34;.upper() +
            &#34;# which will cause all content after it on a given line to be \n&#34;.upper() +
            &#34;# ignored by the program.\n&#34;.upper() +
            &#34;#\n&#34;            
            &#34;# Here is an example of use:\n&#34;
            &#34;#\n&#34;
            &#34;# DIALECT = oracle # enter database dialect\n&#34;
            &#34;# USERNAME = MyName  # enter your username\n&#34;
            &#34;# PASSWORD = An4q6Db458d1w2r8  # enter your password\n&#34;
            &#34;# HOST = localhost  # enter host url (for example localhost)\n&#34;
            &#34;# PORT = 1521  # enter the port number\n&#34;
            &#34;# SERVICE =  orcl.mshome.net  # enter the database service name\n&#34;
            &#34;\n&#34;
            &#34;\n&#34;
            &#34;DIALECT = target_dialect # enter database dialect\n&#34;
            &#34;USERNAME = your_username  # enter your username\n&#34;
            &#34;PASSWORD = your_password  # enter your password\n&#34;
            &#34;HOST = target_host  # enter host url (for example localhost)\n&#34;
            &#34;PORT = target_port_number  # enter the port number\n&#34;
            &#34;SERVICE =  target_service  # enter the database service name\n&#34;
        )
        f.close()
        
        print(&#34;The configuration template has been successfully created.\n&#34;
              f&#34;Path: {root_path}\n&#34;
              f&#34;File: db_connection.cfg&#34;)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="sql_code_analyzer.input.args_handler.CArgs.create_database_connection_file"><code class="name flex">
<span>def <span class="ident">create_database_connection_file</span></span>(<span>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Create a template file as an example for proper database connection.
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_database_connection_file() -&gt; None:
    &#34;&#34;&#34;
    Create a template file as an example for proper database connection.
    :return: None
    &#34;&#34;&#34;

    root_path = create_path_if_not_exists(
        path=ProgramPathConfig.get_database_configuration_path()
    )

    f = open(os.path.join(root_path, &#34;db_connection.cfg&#34;), &#34;w&#34;)
    f.write(
        &#34;##################################################################\n&#34;
        &#34;#############    THIS FILE CONTAINS CONFIGURATION    #############\n&#34;
        &#34;##################################################################\n&#34;
        &#34;# \n&#34;
        &#34;# This file is a configuration template for connecting the program\n&#34;.upper() +
        &#34;# to an existing database. Please replace the words containing\n&#34;.upper() +
        &#34;# the underscore with the data that corresponds to connecting \n&#34;.upper() +
        &#34;# the client to the database.\n&#34;.upper() +
        &#34;# \n&#34;
        &#34;# In this file you can create comments using the grid wildcard (#)\n&#34;.upper() +
        &#34;# which will cause all content after it on a given line to be \n&#34;.upper() +
        &#34;# ignored by the program.\n&#34;.upper() +
        &#34;#\n&#34;            
        &#34;# Here is an example of use:\n&#34;
        &#34;#\n&#34;
        &#34;# DIALECT = oracle # enter database dialect\n&#34;
        &#34;# USERNAME = MyName  # enter your username\n&#34;
        &#34;# PASSWORD = An4q6Db458d1w2r8  # enter your password\n&#34;
        &#34;# HOST = localhost  # enter host url (for example localhost)\n&#34;
        &#34;# PORT = 1521  # enter the port number\n&#34;
        &#34;# SERVICE =  orcl.mshome.net  # enter the database service name\n&#34;
        &#34;\n&#34;
        &#34;\n&#34;
        &#34;DIALECT = target_dialect # enter database dialect\n&#34;
        &#34;USERNAME = your_username  # enter your username\n&#34;
        &#34;PASSWORD = your_password  # enter your password\n&#34;
        &#34;HOST = target_host  # enter host url (for example localhost)\n&#34;
        &#34;PORT = target_port_number  # enter the port number\n&#34;
        &#34;SERVICE =  target_service  # enter the database service name\n&#34;
    )
    f.close()
    
    print(&#34;The configuration template has been successfully created.\n&#34;
          f&#34;Path: {root_path}\n&#34;
          f&#34;File: db_connection.cfg&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sql_code_analyzer.input.args_handler.CArgs.update_parameters"><code class="name flex">
<span>def <span class="ident">update_parameters</span></span>(<span>self, args: <module 'argparse' from 'C:\\Program Files\\Python311\\Lib\\argparse.py'>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Dynamically creates/updates self object properties
:param args: Data that need to be saved to self-object
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_parameters(self, args: argparse) -&gt; None:
    &#34;&#34;&#34;
    Dynamically creates/updates self object properties
    :param args: Data that need to be saved to self-object
    :return: None
    &#34;&#34;&#34;

    for argument, value in vars(args).items():
        setattr(self, argument, value)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sql_code_analyzer.input" href="index.html">sql_code_analyzer.input</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sql_code_analyzer.input.args_handler.parse_args" href="#sql_code_analyzer.input.args_handler.parse_args">parse_args</a></code></li>
<li><code><a title="sql_code_analyzer.input.args_handler.parse_raw_sql_to_statement" href="#sql_code_analyzer.input.args_handler.parse_raw_sql_to_statement">parse_raw_sql_to_statement</a></code></li>
<li><code><a title="sql_code_analyzer.input.args_handler.verify_file_path" href="#sql_code_analyzer.input.args_handler.verify_file_path">verify_file_path</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sql_code_analyzer.input.args_handler.CArgs" href="#sql_code_analyzer.input.args_handler.CArgs">CArgs</a></code></h4>
<ul class="">
<li><code><a title="sql_code_analyzer.input.args_handler.CArgs.create_database_connection_file" href="#sql_code_analyzer.input.args_handler.CArgs.create_database_connection_file">create_database_connection_file</a></code></li>
<li><code><a title="sql_code_analyzer.input.args_handler.CArgs.update_parameters" href="#sql_code_analyzer.input.args_handler.CArgs.update_parameters">update_parameters</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>