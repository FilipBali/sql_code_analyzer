<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sql_code_analyzer.visitor.rules_visitor API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sql_code_analyzer.visitor.rules_visitor</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

import enum
import importlib.util
from queue import LifoQueue


from sql_code_analyzer.checker.rules.base import BaseRule
from sql_code_analyzer.in_memory_representation.struct.database import Database
from sql_code_analyzer.output.enums import ExitWith
from sql_code_analyzer.output.reporter.program_reporter import ProgramReporter
from sql_code_analyzer.tools.path import get_path_object
from sql_code_analyzer.visitor.visitor import Visitor

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from typing import List, Set, Dict


class RuleType(enum.Enum):
    &#34;&#34;&#34;
    Enumerator of rule types.
    Provides an option to call rules when a node is entered or leaved.
    The rule is mostly the root node of some subtree of abstract syntax tree.
    So this provides also provides functionality to call rules when
    subtree is visited or leaved.

    The enumerator value is always combined by node class name.
    By this design, it is possible to call only rules that are
    expecting this kind of node

    _visit rule is called when the node entered/visited.
    _leave rule called when the node leaved.

    Examples of using:
    The node is called: ColumnDef
    ColumnDef provides subtree to definition of column.
    To call rule when ColumnDef is visited, it is necessary to
    create a method called columndef_visit.

    For rule leaving ColumDef-tree the method is columndef_leave.
    &#34;&#34;&#34;

    Visit = &#34;_visit&#34;
    Leave = &#34;_leave&#34;


class RulesVisitor(Visitor):
    &#34;&#34;&#34;
    Provides functionality/logic of RulesVisitor visitor.
    It is specialised to call the rules for visited node.
    It is supporting restrict and permanent features.

    Restrict feature can be used when we want to restrict
    the rule to only some nodes. Restriction is defined by
    appointing the node names.

    Permanent feature is providing an option to have an
    indestructible rule object. When the rule is called
    between nodes, the rule object is always a new instance.
    If a permanent feature is set to true, the object is
    saved and called also with another node. This can
    be useful if we want to transfer data about linting
    from one node to another one.

    &#34;&#34;&#34;
    # def __init__(self, rules_args_data, expect_set):
    def __init__(self, rules_args_data, mem_rep):
        &#34;&#34;&#34;
        Initial method for RulesVisitor instance

        :param rules_args_data: Provides data about available rules and additional data about them.

        :param expect_set: The set of expecting rules. The restrict feature. The expect_set comes from
        a statement that will be visited.
        &#34;&#34;&#34;

        # Parameters
        self.rules_args_data = rules_args_data

        # Memory representation
        self.mem_rep = mem_rep

        # Lint variables
        self._expect_set = set()
        self.node = None
        self.node_to_lint = None
        self.visit_leave_queue = LifoQueue()
        self.reports = []

        # Rules
        self.rules = []
        self.persistent_rules = []
        self.normal_rules = []
        self.temporary_rules = []
        self.restrict_rules = {}
        self.get_rules()

    def clear_lint_variables(self):
        self._expect_set = set()
        self.node = None
        self.node_to_lint = None
        self.visit_leave_queue = LifoQueue()
        self.reports = []
        self._reset_normal_rules()

    def _reset_normal_rules(self):
        for i, rule_object in enumerate(self.normal_rules):
            self.normal_rules[i] = rule_object.__class__()


    @property
    def expect_set(self) -&gt; Set:
        &#34;&#34;&#34;
        The set of expecting rules.
        This is part of the rule restriction feature.
        The expect_set comes from a statement that will be visited.
        :return: The set of expecting rules.
        &#34;&#34;&#34;
        return self._expect_set

    @expect_set.setter
    def expect_set(self, value):
        self._expect_set = value

    @property
    def restrict_rules(self) -&gt; Dict:
        return self._restrict_rules

    @restrict_rules.setter
    def restrict_rules(self, value):
        self._restrict_rules = value

    @property
    def rules_args_data(self):
        return self._rules_args_data

    @rules_args_data.setter
    def rules_args_data(self, value):
        self._rules_args_data = value

    @property
    def node(self):
        return self._node

    @node.setter
    def node(self, value):
        self._node = value

    @property
    def node_to_lint(self):
        return self._node_to_lint

    @node_to_lint.setter
    def node_to_lint(self, value):
        self._node_to_lint = value

    @property
    def rules(self) -&gt; List:
        return self._rules

    @rules.setter
    def rules(self, value):
        self._rules = value

    @property
    def persistent_rules(self) -&gt; List:
        return self._persistent_rules

    @persistent_rules.setter
    def persistent_rules(self, value):
        self._persistent_rules = value

    @property
    def normal_rules(self) -&gt; List:
        return self._normal_rules

    @normal_rules.setter
    def normal_rules(self, value):
        self._normal_rules = value

    @property
    def temporary_rules(self) -&gt; List:
        return self._temporary_rules

    @temporary_rules.setter
    def temporary_rules(self, value):
        self._temporary_rules = value

    @property
    def visit_leave_queue(self) -&gt; LifoQueue:
        return self._visit_leave_queue

    @visit_leave_queue.setter
    def visit_leave_queue(self, value):
        self._visit_leave_queue = value

    @property
    def reports(self) -&gt; List:
        return self._reports

    @reports.setter
    def reports(self, value):
        self._reports = value

    @staticmethod
    def _get_node_type(node) -&gt; str:
        &#34;&#34;&#34;
        Getting the node type as lowered class name.
        Class name is also the node name.

        :param node: The node of abstract syntax tree.
        :return: The name of node type.
        &#34;&#34;&#34;

        return node.__class__.__name__.lower()

    def traversing_ast_done(self) -&gt; None:
        &#34;&#34;&#34;
        It is used when traversing of abstract syntax tree is done.
        Over time as the RuleVisitor visits nodes, there are saved
        _leave functions of these nodes.
        When traversing of the abstract syntax tree is done, there
        are always some _leave functions that need to be called.
        This function does this work.

        :return: None
        &#34;&#34;&#34;

        &#34;&#34;&#34;
        Pop all and call visit_leave
        If node is None, then already
        iterated through all nodes,
        so we just check remaining nodes
        in queue which are waiting for
        _leave function call
        &#34;&#34;&#34;
        while not self.visit_leave_queue.empty():
            self.node_to_lint = self.visit_leave_queue.get()
            self.lint_node(RuleType.Leave)

    def visit(self, node) -&gt; None:
        &#34;&#34;&#34;
        Provides the main logic of RuleVisitor.
        As the abstract syntax tree is traversed,
        the visit function calls the rules over
        particular nodes and provides node linting.

        :param node: Node which will be visited
        :return: None
        &#34;&#34;&#34;

        # Save node
        self.node = node

        if self.visit_leave_queue.empty():
            self.visit_leave_queue.put(node)

            self.node_to_lint = self.node
            self.lint_node(visit_or_leave=RuleType.Visit)

        else:
            prev_node = self.visit_leave_queue.get()
            if node.depth &gt; prev_node.depth:

                # prev_node == 2
                #      node == 3
                #
                # Going from node 2 to node 3
                # As we are going to more depth
                # there is no need to call _leave function
                # because we are not leaving subtree
                # bud instead entering new one
                #             ---
                #            | 1 |
                #             ---
                #            /   \
                #          ---    ---
                #         | 2 |  | 4 |
                #          ---    ---
                #         /
                #       ---
                #      | 3 |
                #       ---

                self.visit_leave_queue.put(prev_node)

                self.visit_leave_queue.put(node)
                self.node_to_lint = self.node
                self.lint_node(visit_or_leave=RuleType.Visit)

            elif node.depth == prev_node.depth:
                # call visit_leave on prev_node

                # prev_node == 2
                #      node == 4
                #
                # Going from node 2 to node 4
                # As we are going to visit sibling node
                # we must call _leave function to all
                # nodes in node 2 sub-tree
                #             ---
                #            | 1 |
                #             ---
                #            /   \
                #          ---    ---
                #         | 2 |  | 4 |
                #          ---    ---

                self.node_to_lint = prev_node
                self.lint_node(visit_or_leave=RuleType.Leave)

                self.visit_leave_queue.put(node)
                self.node_to_lint = node
                self.lint_node(visit_or_leave=RuleType.Visit)

            elif node.depth &lt; prev_node.depth:
                # pop queue and call visit_leave until prev_node.depth is not equal

                # prev_node == 3
                #      node == 4
                # Going from node 3 to node 4
                # As we are going to visit upper node
                # we must call _leave function to all
                # nodes in node 2 subtree
                # We can use that node 2 and node 4
                # are in the same depth,
                # so we call _leave function for all
                # nodes which have depth &lt;= node 4
                #
                #             ---
                #            | 1 |
                #             ---
                #            /   \
                #          ---    ---
                #         | 2 |  | 4 |
                #          ---    ---
                #         /
                #       ---
                #      | 3 |
                #       ---

                self.visit_leave_queue.put(prev_node)
                while not self.visit_leave_queue.empty():
                    self.node_to_lint = self.visit_leave_queue.get()
                    self.lint_node(RuleType.Leave)

                    if self.node_to_lint.depth == node.depth:
                        break

                self.visit_leave_queue.put(node)
                self.node_to_lint = node
                self.lint_node(RuleType.Visit)

            else:
                ProgramReporter.show_error_message(
                    message=&#34;Unexpected error during evaluating rules.&#34;,
                    exit_code=ExitWith.InternalError
                )

    def lint_node(self, visit_or_leave) -&gt; None:
        &#34;&#34;&#34;
        This function encapsulates the application of rules
        to a node.

        :param visit_or_leave: Specify a rule type.
        :return: None
        &#34;&#34;&#34;

        # Apply rules based on a node type
        self.apply_rules(visit_or_leave=visit_or_leave)

    def apply_rules(self, visit_or_leave: RuleType) -&gt; None:
        &#34;&#34;&#34;
        Provides logic of application of particular
        rules to node.

        :param visit_or_leave: Specify a rule type.
        :return: None
        &#34;&#34;&#34;

        # Get rules that satisfy restrictions or have no restrictions
        rules_result = [obj for obj, restrictions in self.restrict_rules.items()
                        if not restrictions or restrictions.intersection(self.expect_set)]

        # Iterating over rules which comply with restriction
        for rule in rules_result:

            rule_instance = None

            # Search for persistent rule if persistent
            if hasattr(rule, &#34;persistent&#34;) and rule.persistent is True:
                for item in self.persistent_rules:
                    if type(item) is rule:
                        rule_instance = item
                        break

            # Create temporary rule if temporary
            elif hasattr(rule, &#34;temporary&#34;) and rule.temporary is True:
                rule_instance = rule()

            # Search for normal rule if temporary
            else:
                for item in self.normal_rules:
                    if type(item) is rule:
                        rule_instance = item
                        break

            # If instance of rule is still None(instance not found), then error, program integrity violated
            if rule_instance is None:
                ProgramReporter.show_warning_message(
                    message=f&#34;The program could not find the rule object of class {rule.__name__},\n&#34;
                            &#34;this can occur when program integrity is violated.&#34;
                )
                continue

            # Check if the rule class has _visit method for this node
            if hasattr(rule_instance, self._get_node_type(node=self.node_to_lint) + visit_or_leave.value) and \
               callable(getattr(rule_instance, self._get_node_type(node=self.node_to_lint) + visit_or_leave.value)):

                rule_instance.node = self.node_to_lint
                rule_instance.mem_rep = self.mem_rep

                # Get the method
                rule_method = getattr(rule_instance, self._get_node_type(node=self.node_to_lint) + visit_or_leave.value)

                # Call/Apply rule
                self.call_rule(rule_method=rule_method)

    def get_rules(self) -&gt; None:
        &#34;&#34;&#34;
        Extracts a list of rule files from the data obtained by processing program arguments.

        :return: None
        &#34;&#34;&#34;

        # Go through all rule files
        for path in self.rules_args_data.paths:
            path_object = get_path_object(path)

            try:

                # Load file as module
                # Necessary to access the content
                spec = importlib.util.spec_from_file_location(path, path)
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)

                # Check if the file has register method
                if &#34;register&#34; in dir(module):

                    try:
                        # Get method
                        register_method = getattr(module, &#34;register&#34;)

                        # Apply registration to this visitor
                        register_method(self)

                    except TypeError as e:
                        ProgramReporter.show_warning_message(
                            message=f&#34;Unable to register rule in {path_object.name},&#34;
                                    &#34;probably missing parameter for checker.\n&#34;
                                    f&#34;Python interpreter report: {e}&#34;
                        )

                    except Exception as e:
                        ProgramReporter.show_warning_message(
                            message=f&#34;Unable to register rule in {path_object.name}.\n&#34;
                                    f&#34;Python interpreter report: {e}&#34;
                        )

            except (Exception, ) as e:
                ProgramReporter.show_warning_message(
                    message=f&#34;Unable to load a module with rule in {path_object.name}.\n&#34;
                            f&#34;Python interpreter report: {e}&#34;
                )

    def register_rule(self, rule) -&gt; None:
        &#34;&#34;&#34;
        Registers particular rules for their further use for node checking.

        :param rule: The rule class
        :return: Nome
        &#34;&#34;&#34;

        if hasattr(rule, &#34;persistent&#34;) and rule.persistent is True and \
                hasattr(rule, &#34;temporary&#34;) and rule.temporary is True:
            ProgramReporter.show_warning_message(
                message=&#34;Bad configuration rule, functions persistent and temporary are mutually exclusive.\n&#34;
                        f&#34;Rule {rule.__name__} will not be accepted for checking.&#34;
            )
            return

        # Register rule
        self.rules.append(rule)

        if hasattr(rule, &#34;persistent&#34;) and rule.persistent is True:
            self.persistent_rules.append(rule())

        elif hasattr(rule, &#34;temporary&#34;) and rule.temporary is True:
            self.temporary_rules.append(rule())

        else:
            self.normal_rules.append(rule())

        if hasattr(rule, &#34;restrict&#34;):
            self.restrict_rules[rule] = rule.restrict

        else:
            self.restrict_rules[rule] = {}

    def call_rule(self, rule_method) -&gt; None:
        &#34;&#34;&#34;
        Call the rule on the node and save the reports.

        :param rule_method: Particular rule method
        :return: None
        &#34;&#34;&#34;

        reports: BaseRule = rule_method()
        self.save_reports(reports=reports)

    def save_reports(self, reports) -&gt; None:
        &#34;&#34;&#34;
        The logic of storing reports from the rule.

        :param reports: BaseRule object
        :return: None
        &#34;&#34;&#34;

        if reports is None:
            return

        reports = reports.get_reports()
        for report in reports:
            self.reports.append(report)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sql_code_analyzer.visitor.rules_visitor.RuleType"><code class="flex name class">
<span>class <span class="ident">RuleType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p>Enumerator of rule types.
Provides an option to call rules when a node is entered or leaved.
The rule is mostly the root node of some subtree of abstract syntax tree.
So this provides also provides functionality to call rules when
subtree is visited or leaved.</p>
<p>The enumerator value is always combined by node class name.
By this design, it is possible to call only rules that are
expecting this kind of node</p>
<p>_visit rule is called when the node entered/visited.
_leave rule called when the node leaved.</p>
<p>Examples of using:
The node is called: ColumnDef
ColumnDef provides subtree to definition of column.
To call rule when ColumnDef is visited, it is necessary to
create a method called columndef_visit.</p>
<p>For rule leaving ColumDef-tree the method is columndef_leave.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RuleType(enum.Enum):
    &#34;&#34;&#34;
    Enumerator of rule types.
    Provides an option to call rules when a node is entered or leaved.
    The rule is mostly the root node of some subtree of abstract syntax tree.
    So this provides also provides functionality to call rules when
    subtree is visited or leaved.

    The enumerator value is always combined by node class name.
    By this design, it is possible to call only rules that are
    expecting this kind of node

    _visit rule is called when the node entered/visited.
    _leave rule called when the node leaved.

    Examples of using:
    The node is called: ColumnDef
    ColumnDef provides subtree to definition of column.
    To call rule when ColumnDef is visited, it is necessary to
    create a method called columndef_visit.

    For rule leaving ColumDef-tree the method is columndef_leave.
    &#34;&#34;&#34;

    Visit = &#34;_visit&#34;
    Leave = &#34;_leave&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sql_code_analyzer.visitor.rules_visitor.RuleType.Leave"><code class="name">var <span class="ident">Leave</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sql_code_analyzer.visitor.rules_visitor.RuleType.Visit"><code class="name">var <span class="ident">Visit</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sql_code_analyzer.visitor.rules_visitor.RulesVisitor"><code class="flex name class">
<span>class <span class="ident">RulesVisitor</span></span>
<span>(</span><span>rules_args_data, mem_rep)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides functionality/logic of RulesVisitor visitor.
It is specialised to call the rules for visited node.
It is supporting restrict and permanent features.</p>
<p>Restrict feature can be used when we want to restrict
the rule to only some nodes. Restriction is defined by
appointing the node names.</p>
<p>Permanent feature is providing an option to have an
indestructible rule object. When the rule is called
between nodes, the rule object is always a new instance.
If a permanent feature is set to true, the object is
saved and called also with another node. This can
be useful if we want to transfer data about linting
from one node to another one.</p>
<p>Initial method for RulesVisitor instance</p>
<p>:param rules_args_data: Provides data about available rules and additional data about them.</p>
<p>:param expect_set: The set of expecting rules. The restrict feature. The expect_set comes from
a statement that will be visited.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RulesVisitor(Visitor):
    &#34;&#34;&#34;
    Provides functionality/logic of RulesVisitor visitor.
    It is specialised to call the rules for visited node.
    It is supporting restrict and permanent features.

    Restrict feature can be used when we want to restrict
    the rule to only some nodes. Restriction is defined by
    appointing the node names.

    Permanent feature is providing an option to have an
    indestructible rule object. When the rule is called
    between nodes, the rule object is always a new instance.
    If a permanent feature is set to true, the object is
    saved and called also with another node. This can
    be useful if we want to transfer data about linting
    from one node to another one.

    &#34;&#34;&#34;
    # def __init__(self, rules_args_data, expect_set):
    def __init__(self, rules_args_data, mem_rep):
        &#34;&#34;&#34;
        Initial method for RulesVisitor instance

        :param rules_args_data: Provides data about available rules and additional data about them.

        :param expect_set: The set of expecting rules. The restrict feature. The expect_set comes from
        a statement that will be visited.
        &#34;&#34;&#34;

        # Parameters
        self.rules_args_data = rules_args_data

        # Memory representation
        self.mem_rep = mem_rep

        # Lint variables
        self._expect_set = set()
        self.node = None
        self.node_to_lint = None
        self.visit_leave_queue = LifoQueue()
        self.reports = []

        # Rules
        self.rules = []
        self.persistent_rules = []
        self.normal_rules = []
        self.temporary_rules = []
        self.restrict_rules = {}
        self.get_rules()

    def clear_lint_variables(self):
        self._expect_set = set()
        self.node = None
        self.node_to_lint = None
        self.visit_leave_queue = LifoQueue()
        self.reports = []
        self._reset_normal_rules()

    def _reset_normal_rules(self):
        for i, rule_object in enumerate(self.normal_rules):
            self.normal_rules[i] = rule_object.__class__()


    @property
    def expect_set(self) -&gt; Set:
        &#34;&#34;&#34;
        The set of expecting rules.
        This is part of the rule restriction feature.
        The expect_set comes from a statement that will be visited.
        :return: The set of expecting rules.
        &#34;&#34;&#34;
        return self._expect_set

    @expect_set.setter
    def expect_set(self, value):
        self._expect_set = value

    @property
    def restrict_rules(self) -&gt; Dict:
        return self._restrict_rules

    @restrict_rules.setter
    def restrict_rules(self, value):
        self._restrict_rules = value

    @property
    def rules_args_data(self):
        return self._rules_args_data

    @rules_args_data.setter
    def rules_args_data(self, value):
        self._rules_args_data = value

    @property
    def node(self):
        return self._node

    @node.setter
    def node(self, value):
        self._node = value

    @property
    def node_to_lint(self):
        return self._node_to_lint

    @node_to_lint.setter
    def node_to_lint(self, value):
        self._node_to_lint = value

    @property
    def rules(self) -&gt; List:
        return self._rules

    @rules.setter
    def rules(self, value):
        self._rules = value

    @property
    def persistent_rules(self) -&gt; List:
        return self._persistent_rules

    @persistent_rules.setter
    def persistent_rules(self, value):
        self._persistent_rules = value

    @property
    def normal_rules(self) -&gt; List:
        return self._normal_rules

    @normal_rules.setter
    def normal_rules(self, value):
        self._normal_rules = value

    @property
    def temporary_rules(self) -&gt; List:
        return self._temporary_rules

    @temporary_rules.setter
    def temporary_rules(self, value):
        self._temporary_rules = value

    @property
    def visit_leave_queue(self) -&gt; LifoQueue:
        return self._visit_leave_queue

    @visit_leave_queue.setter
    def visit_leave_queue(self, value):
        self._visit_leave_queue = value

    @property
    def reports(self) -&gt; List:
        return self._reports

    @reports.setter
    def reports(self, value):
        self._reports = value

    @staticmethod
    def _get_node_type(node) -&gt; str:
        &#34;&#34;&#34;
        Getting the node type as lowered class name.
        Class name is also the node name.

        :param node: The node of abstract syntax tree.
        :return: The name of node type.
        &#34;&#34;&#34;

        return node.__class__.__name__.lower()

    def traversing_ast_done(self) -&gt; None:
        &#34;&#34;&#34;
        It is used when traversing of abstract syntax tree is done.
        Over time as the RuleVisitor visits nodes, there are saved
        _leave functions of these nodes.
        When traversing of the abstract syntax tree is done, there
        are always some _leave functions that need to be called.
        This function does this work.

        :return: None
        &#34;&#34;&#34;

        &#34;&#34;&#34;
        Pop all and call visit_leave
        If node is None, then already
        iterated through all nodes,
        so we just check remaining nodes
        in queue which are waiting for
        _leave function call
        &#34;&#34;&#34;
        while not self.visit_leave_queue.empty():
            self.node_to_lint = self.visit_leave_queue.get()
            self.lint_node(RuleType.Leave)

    def visit(self, node) -&gt; None:
        &#34;&#34;&#34;
        Provides the main logic of RuleVisitor.
        As the abstract syntax tree is traversed,
        the visit function calls the rules over
        particular nodes and provides node linting.

        :param node: Node which will be visited
        :return: None
        &#34;&#34;&#34;

        # Save node
        self.node = node

        if self.visit_leave_queue.empty():
            self.visit_leave_queue.put(node)

            self.node_to_lint = self.node
            self.lint_node(visit_or_leave=RuleType.Visit)

        else:
            prev_node = self.visit_leave_queue.get()
            if node.depth &gt; prev_node.depth:

                # prev_node == 2
                #      node == 3
                #
                # Going from node 2 to node 3
                # As we are going to more depth
                # there is no need to call _leave function
                # because we are not leaving subtree
                # bud instead entering new one
                #             ---
                #            | 1 |
                #             ---
                #            /   \
                #          ---    ---
                #         | 2 |  | 4 |
                #          ---    ---
                #         /
                #       ---
                #      | 3 |
                #       ---

                self.visit_leave_queue.put(prev_node)

                self.visit_leave_queue.put(node)
                self.node_to_lint = self.node
                self.lint_node(visit_or_leave=RuleType.Visit)

            elif node.depth == prev_node.depth:
                # call visit_leave on prev_node

                # prev_node == 2
                #      node == 4
                #
                # Going from node 2 to node 4
                # As we are going to visit sibling node
                # we must call _leave function to all
                # nodes in node 2 sub-tree
                #             ---
                #            | 1 |
                #             ---
                #            /   \
                #          ---    ---
                #         | 2 |  | 4 |
                #          ---    ---

                self.node_to_lint = prev_node
                self.lint_node(visit_or_leave=RuleType.Leave)

                self.visit_leave_queue.put(node)
                self.node_to_lint = node
                self.lint_node(visit_or_leave=RuleType.Visit)

            elif node.depth &lt; prev_node.depth:
                # pop queue and call visit_leave until prev_node.depth is not equal

                # prev_node == 3
                #      node == 4
                # Going from node 3 to node 4
                # As we are going to visit upper node
                # we must call _leave function to all
                # nodes in node 2 subtree
                # We can use that node 2 and node 4
                # are in the same depth,
                # so we call _leave function for all
                # nodes which have depth &lt;= node 4
                #
                #             ---
                #            | 1 |
                #             ---
                #            /   \
                #          ---    ---
                #         | 2 |  | 4 |
                #          ---    ---
                #         /
                #       ---
                #      | 3 |
                #       ---

                self.visit_leave_queue.put(prev_node)
                while not self.visit_leave_queue.empty():
                    self.node_to_lint = self.visit_leave_queue.get()
                    self.lint_node(RuleType.Leave)

                    if self.node_to_lint.depth == node.depth:
                        break

                self.visit_leave_queue.put(node)
                self.node_to_lint = node
                self.lint_node(RuleType.Visit)

            else:
                ProgramReporter.show_error_message(
                    message=&#34;Unexpected error during evaluating rules.&#34;,
                    exit_code=ExitWith.InternalError
                )

    def lint_node(self, visit_or_leave) -&gt; None:
        &#34;&#34;&#34;
        This function encapsulates the application of rules
        to a node.

        :param visit_or_leave: Specify a rule type.
        :return: None
        &#34;&#34;&#34;

        # Apply rules based on a node type
        self.apply_rules(visit_or_leave=visit_or_leave)

    def apply_rules(self, visit_or_leave: RuleType) -&gt; None:
        &#34;&#34;&#34;
        Provides logic of application of particular
        rules to node.

        :param visit_or_leave: Specify a rule type.
        :return: None
        &#34;&#34;&#34;

        # Get rules that satisfy restrictions or have no restrictions
        rules_result = [obj for obj, restrictions in self.restrict_rules.items()
                        if not restrictions or restrictions.intersection(self.expect_set)]

        # Iterating over rules which comply with restriction
        for rule in rules_result:

            rule_instance = None

            # Search for persistent rule if persistent
            if hasattr(rule, &#34;persistent&#34;) and rule.persistent is True:
                for item in self.persistent_rules:
                    if type(item) is rule:
                        rule_instance = item
                        break

            # Create temporary rule if temporary
            elif hasattr(rule, &#34;temporary&#34;) and rule.temporary is True:
                rule_instance = rule()

            # Search for normal rule if temporary
            else:
                for item in self.normal_rules:
                    if type(item) is rule:
                        rule_instance = item
                        break

            # If instance of rule is still None(instance not found), then error, program integrity violated
            if rule_instance is None:
                ProgramReporter.show_warning_message(
                    message=f&#34;The program could not find the rule object of class {rule.__name__},\n&#34;
                            &#34;this can occur when program integrity is violated.&#34;
                )
                continue

            # Check if the rule class has _visit method for this node
            if hasattr(rule_instance, self._get_node_type(node=self.node_to_lint) + visit_or_leave.value) and \
               callable(getattr(rule_instance, self._get_node_type(node=self.node_to_lint) + visit_or_leave.value)):

                rule_instance.node = self.node_to_lint
                rule_instance.mem_rep = self.mem_rep

                # Get the method
                rule_method = getattr(rule_instance, self._get_node_type(node=self.node_to_lint) + visit_or_leave.value)

                # Call/Apply rule
                self.call_rule(rule_method=rule_method)

    def get_rules(self) -&gt; None:
        &#34;&#34;&#34;
        Extracts a list of rule files from the data obtained by processing program arguments.

        :return: None
        &#34;&#34;&#34;

        # Go through all rule files
        for path in self.rules_args_data.paths:
            path_object = get_path_object(path)

            try:

                # Load file as module
                # Necessary to access the content
                spec = importlib.util.spec_from_file_location(path, path)
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)

                # Check if the file has register method
                if &#34;register&#34; in dir(module):

                    try:
                        # Get method
                        register_method = getattr(module, &#34;register&#34;)

                        # Apply registration to this visitor
                        register_method(self)

                    except TypeError as e:
                        ProgramReporter.show_warning_message(
                            message=f&#34;Unable to register rule in {path_object.name},&#34;
                                    &#34;probably missing parameter for checker.\n&#34;
                                    f&#34;Python interpreter report: {e}&#34;
                        )

                    except Exception as e:
                        ProgramReporter.show_warning_message(
                            message=f&#34;Unable to register rule in {path_object.name}.\n&#34;
                                    f&#34;Python interpreter report: {e}&#34;
                        )

            except (Exception, ) as e:
                ProgramReporter.show_warning_message(
                    message=f&#34;Unable to load a module with rule in {path_object.name}.\n&#34;
                            f&#34;Python interpreter report: {e}&#34;
                )

    def register_rule(self, rule) -&gt; None:
        &#34;&#34;&#34;
        Registers particular rules for their further use for node checking.

        :param rule: The rule class
        :return: Nome
        &#34;&#34;&#34;

        if hasattr(rule, &#34;persistent&#34;) and rule.persistent is True and \
                hasattr(rule, &#34;temporary&#34;) and rule.temporary is True:
            ProgramReporter.show_warning_message(
                message=&#34;Bad configuration rule, functions persistent and temporary are mutually exclusive.\n&#34;
                        f&#34;Rule {rule.__name__} will not be accepted for checking.&#34;
            )
            return

        # Register rule
        self.rules.append(rule)

        if hasattr(rule, &#34;persistent&#34;) and rule.persistent is True:
            self.persistent_rules.append(rule())

        elif hasattr(rule, &#34;temporary&#34;) and rule.temporary is True:
            self.temporary_rules.append(rule())

        else:
            self.normal_rules.append(rule())

        if hasattr(rule, &#34;restrict&#34;):
            self.restrict_rules[rule] = rule.restrict

        else:
            self.restrict_rules[rule] = {}

    def call_rule(self, rule_method) -&gt; None:
        &#34;&#34;&#34;
        Call the rule on the node and save the reports.

        :param rule_method: Particular rule method
        :return: None
        &#34;&#34;&#34;

        reports: BaseRule = rule_method()
        self.save_reports(reports=reports)

    def save_reports(self, reports) -&gt; None:
        &#34;&#34;&#34;
        The logic of storing reports from the rule.

        :param reports: BaseRule object
        :return: None
        &#34;&#34;&#34;

        if reports is None:
            return

        reports = reports.get_reports()
        for report in reports:
            self.reports.append(report)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sql_code_analyzer.visitor.visitor.Visitor" href="visitor.html#sql_code_analyzer.visitor.visitor.Visitor">Visitor</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.expect_set"><code class="name">var <span class="ident">expect_set</span> : Set</code></dt>
<dd>
<div class="desc"><p>The set of expecting rules.
This is part of the rule restriction feature.
The expect_set comes from a statement that will be visited.
:return: The set of expecting rules.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def expect_set(self) -&gt; Set:
    &#34;&#34;&#34;
    The set of expecting rules.
    This is part of the rule restriction feature.
    The expect_set comes from a statement that will be visited.
    :return: The set of expecting rules.
    &#34;&#34;&#34;
    return self._expect_set</code></pre>
</details>
</dd>
<dt id="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.node"><code class="name">var <span class="ident">node</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def node(self):
    return self._node</code></pre>
</details>
</dd>
<dt id="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.node_to_lint"><code class="name">var <span class="ident">node_to_lint</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def node_to_lint(self):
    return self._node_to_lint</code></pre>
</details>
</dd>
<dt id="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.normal_rules"><code class="name">var <span class="ident">normal_rules</span> : List</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def normal_rules(self) -&gt; List:
    return self._normal_rules</code></pre>
</details>
</dd>
<dt id="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.persistent_rules"><code class="name">var <span class="ident">persistent_rules</span> : List</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def persistent_rules(self) -&gt; List:
    return self._persistent_rules</code></pre>
</details>
</dd>
<dt id="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.reports"><code class="name">var <span class="ident">reports</span> : List</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def reports(self) -&gt; List:
    return self._reports</code></pre>
</details>
</dd>
<dt id="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.restrict_rules"><code class="name">var <span class="ident">restrict_rules</span> : Dict</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def restrict_rules(self) -&gt; Dict:
    return self._restrict_rules</code></pre>
</details>
</dd>
<dt id="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.rules"><code class="name">var <span class="ident">rules</span> : List</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rules(self) -&gt; List:
    return self._rules</code></pre>
</details>
</dd>
<dt id="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.rules_args_data"><code class="name">var <span class="ident">rules_args_data</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rules_args_data(self):
    return self._rules_args_data</code></pre>
</details>
</dd>
<dt id="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.temporary_rules"><code class="name">var <span class="ident">temporary_rules</span> : List</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def temporary_rules(self) -&gt; List:
    return self._temporary_rules</code></pre>
</details>
</dd>
<dt id="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.visit_leave_queue"><code class="name">var <span class="ident">visit_leave_queue</span> : queue.LifoQueue</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def visit_leave_queue(self) -&gt; LifoQueue:
    return self._visit_leave_queue</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.apply_rules"><code class="name flex">
<span>def <span class="ident">apply_rules</span></span>(<span>self, visit_or_leave: <a title="sql_code_analyzer.visitor.rules_visitor.RuleType" href="#sql_code_analyzer.visitor.rules_visitor.RuleType">RuleType</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Provides logic of application of particular
rules to node.</p>
<p>:param visit_or_leave: Specify a rule type.
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_rules(self, visit_or_leave: RuleType) -&gt; None:
    &#34;&#34;&#34;
    Provides logic of application of particular
    rules to node.

    :param visit_or_leave: Specify a rule type.
    :return: None
    &#34;&#34;&#34;

    # Get rules that satisfy restrictions or have no restrictions
    rules_result = [obj for obj, restrictions in self.restrict_rules.items()
                    if not restrictions or restrictions.intersection(self.expect_set)]

    # Iterating over rules which comply with restriction
    for rule in rules_result:

        rule_instance = None

        # Search for persistent rule if persistent
        if hasattr(rule, &#34;persistent&#34;) and rule.persistent is True:
            for item in self.persistent_rules:
                if type(item) is rule:
                    rule_instance = item
                    break

        # Create temporary rule if temporary
        elif hasattr(rule, &#34;temporary&#34;) and rule.temporary is True:
            rule_instance = rule()

        # Search for normal rule if temporary
        else:
            for item in self.normal_rules:
                if type(item) is rule:
                    rule_instance = item
                    break

        # If instance of rule is still None(instance not found), then error, program integrity violated
        if rule_instance is None:
            ProgramReporter.show_warning_message(
                message=f&#34;The program could not find the rule object of class {rule.__name__},\n&#34;
                        &#34;this can occur when program integrity is violated.&#34;
            )
            continue

        # Check if the rule class has _visit method for this node
        if hasattr(rule_instance, self._get_node_type(node=self.node_to_lint) + visit_or_leave.value) and \
           callable(getattr(rule_instance, self._get_node_type(node=self.node_to_lint) + visit_or_leave.value)):

            rule_instance.node = self.node_to_lint
            rule_instance.mem_rep = self.mem_rep

            # Get the method
            rule_method = getattr(rule_instance, self._get_node_type(node=self.node_to_lint) + visit_or_leave.value)

            # Call/Apply rule
            self.call_rule(rule_method=rule_method)</code></pre>
</details>
</dd>
<dt id="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.call_rule"><code class="name flex">
<span>def <span class="ident">call_rule</span></span>(<span>self, rule_method) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Call the rule on the node and save the reports.</p>
<p>:param rule_method: Particular rule method
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call_rule(self, rule_method) -&gt; None:
    &#34;&#34;&#34;
    Call the rule on the node and save the reports.

    :param rule_method: Particular rule method
    :return: None
    &#34;&#34;&#34;

    reports: BaseRule = rule_method()
    self.save_reports(reports=reports)</code></pre>
</details>
</dd>
<dt id="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.clear_lint_variables"><code class="name flex">
<span>def <span class="ident">clear_lint_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_lint_variables(self):
    self._expect_set = set()
    self.node = None
    self.node_to_lint = None
    self.visit_leave_queue = LifoQueue()
    self.reports = []
    self._reset_normal_rules()</code></pre>
</details>
</dd>
<dt id="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.get_rules"><code class="name flex">
<span>def <span class="ident">get_rules</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Extracts a list of rule files from the data obtained by processing program arguments.</p>
<p>:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rules(self) -&gt; None:
    &#34;&#34;&#34;
    Extracts a list of rule files from the data obtained by processing program arguments.

    :return: None
    &#34;&#34;&#34;

    # Go through all rule files
    for path in self.rules_args_data.paths:
        path_object = get_path_object(path)

        try:

            # Load file as module
            # Necessary to access the content
            spec = importlib.util.spec_from_file_location(path, path)
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)

            # Check if the file has register method
            if &#34;register&#34; in dir(module):

                try:
                    # Get method
                    register_method = getattr(module, &#34;register&#34;)

                    # Apply registration to this visitor
                    register_method(self)

                except TypeError as e:
                    ProgramReporter.show_warning_message(
                        message=f&#34;Unable to register rule in {path_object.name},&#34;
                                &#34;probably missing parameter for checker.\n&#34;
                                f&#34;Python interpreter report: {e}&#34;
                    )

                except Exception as e:
                    ProgramReporter.show_warning_message(
                        message=f&#34;Unable to register rule in {path_object.name}.\n&#34;
                                f&#34;Python interpreter report: {e}&#34;
                    )

        except (Exception, ) as e:
            ProgramReporter.show_warning_message(
                message=f&#34;Unable to load a module with rule in {path_object.name}.\n&#34;
                        f&#34;Python interpreter report: {e}&#34;
            )</code></pre>
</details>
</dd>
<dt id="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.lint_node"><code class="name flex">
<span>def <span class="ident">lint_node</span></span>(<span>self, visit_or_leave) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>This function encapsulates the application of rules
to a node.</p>
<p>:param visit_or_leave: Specify a rule type.
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lint_node(self, visit_or_leave) -&gt; None:
    &#34;&#34;&#34;
    This function encapsulates the application of rules
    to a node.

    :param visit_or_leave: Specify a rule type.
    :return: None
    &#34;&#34;&#34;

    # Apply rules based on a node type
    self.apply_rules(visit_or_leave=visit_or_leave)</code></pre>
</details>
</dd>
<dt id="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.register_rule"><code class="name flex">
<span>def <span class="ident">register_rule</span></span>(<span>self, rule) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Registers particular rules for their further use for node checking.</p>
<p>:param rule: The rule class
:return: Nome</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_rule(self, rule) -&gt; None:
    &#34;&#34;&#34;
    Registers particular rules for their further use for node checking.

    :param rule: The rule class
    :return: Nome
    &#34;&#34;&#34;

    if hasattr(rule, &#34;persistent&#34;) and rule.persistent is True and \
            hasattr(rule, &#34;temporary&#34;) and rule.temporary is True:
        ProgramReporter.show_warning_message(
            message=&#34;Bad configuration rule, functions persistent and temporary are mutually exclusive.\n&#34;
                    f&#34;Rule {rule.__name__} will not be accepted for checking.&#34;
        )
        return

    # Register rule
    self.rules.append(rule)

    if hasattr(rule, &#34;persistent&#34;) and rule.persistent is True:
        self.persistent_rules.append(rule())

    elif hasattr(rule, &#34;temporary&#34;) and rule.temporary is True:
        self.temporary_rules.append(rule())

    else:
        self.normal_rules.append(rule())

    if hasattr(rule, &#34;restrict&#34;):
        self.restrict_rules[rule] = rule.restrict

    else:
        self.restrict_rules[rule] = {}</code></pre>
</details>
</dd>
<dt id="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.save_reports"><code class="name flex">
<span>def <span class="ident">save_reports</span></span>(<span>self, reports) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>The logic of storing reports from the rule.</p>
<p>:param reports: BaseRule object
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_reports(self, reports) -&gt; None:
    &#34;&#34;&#34;
    The logic of storing reports from the rule.

    :param reports: BaseRule object
    :return: None
    &#34;&#34;&#34;

    if reports is None:
        return

    reports = reports.get_reports()
    for report in reports:
        self.reports.append(report)</code></pre>
</details>
</dd>
<dt id="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.traversing_ast_done"><code class="name flex">
<span>def <span class="ident">traversing_ast_done</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>It is used when traversing of abstract syntax tree is done.
Over time as the RuleVisitor visits nodes, there are saved
_leave functions of these nodes.
When traversing of the abstract syntax tree is done, there
are always some _leave functions that need to be called.
This function does this work.</p>
<p>:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def traversing_ast_done(self) -&gt; None:
    &#34;&#34;&#34;
    It is used when traversing of abstract syntax tree is done.
    Over time as the RuleVisitor visits nodes, there are saved
    _leave functions of these nodes.
    When traversing of the abstract syntax tree is done, there
    are always some _leave functions that need to be called.
    This function does this work.

    :return: None
    &#34;&#34;&#34;

    &#34;&#34;&#34;
    Pop all and call visit_leave
    If node is None, then already
    iterated through all nodes,
    so we just check remaining nodes
    in queue which are waiting for
    _leave function call
    &#34;&#34;&#34;
    while not self.visit_leave_queue.empty():
        self.node_to_lint = self.visit_leave_queue.get()
        self.lint_node(RuleType.Leave)</code></pre>
</details>
</dd>
<dt id="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, node) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Provides the main logic of RuleVisitor.
As the abstract syntax tree is traversed,
the visit function calls the rules over
particular nodes and provides node linting.</p>
<p>:param node: Node which will be visited
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit(self, node) -&gt; None:
    &#34;&#34;&#34;
    Provides the main logic of RuleVisitor.
    As the abstract syntax tree is traversed,
    the visit function calls the rules over
    particular nodes and provides node linting.

    :param node: Node which will be visited
    :return: None
    &#34;&#34;&#34;

    # Save node
    self.node = node

    if self.visit_leave_queue.empty():
        self.visit_leave_queue.put(node)

        self.node_to_lint = self.node
        self.lint_node(visit_or_leave=RuleType.Visit)

    else:
        prev_node = self.visit_leave_queue.get()
        if node.depth &gt; prev_node.depth:

            # prev_node == 2
            #      node == 3
            #
            # Going from node 2 to node 3
            # As we are going to more depth
            # there is no need to call _leave function
            # because we are not leaving subtree
            # bud instead entering new one
            #             ---
            #            | 1 |
            #             ---
            #            /   \
            #          ---    ---
            #         | 2 |  | 4 |
            #          ---    ---
            #         /
            #       ---
            #      | 3 |
            #       ---

            self.visit_leave_queue.put(prev_node)

            self.visit_leave_queue.put(node)
            self.node_to_lint = self.node
            self.lint_node(visit_or_leave=RuleType.Visit)

        elif node.depth == prev_node.depth:
            # call visit_leave on prev_node

            # prev_node == 2
            #      node == 4
            #
            # Going from node 2 to node 4
            # As we are going to visit sibling node
            # we must call _leave function to all
            # nodes in node 2 sub-tree
            #             ---
            #            | 1 |
            #             ---
            #            /   \
            #          ---    ---
            #         | 2 |  | 4 |
            #          ---    ---

            self.node_to_lint = prev_node
            self.lint_node(visit_or_leave=RuleType.Leave)

            self.visit_leave_queue.put(node)
            self.node_to_lint = node
            self.lint_node(visit_or_leave=RuleType.Visit)

        elif node.depth &lt; prev_node.depth:
            # pop queue and call visit_leave until prev_node.depth is not equal

            # prev_node == 3
            #      node == 4
            # Going from node 3 to node 4
            # As we are going to visit upper node
            # we must call _leave function to all
            # nodes in node 2 subtree
            # We can use that node 2 and node 4
            # are in the same depth,
            # so we call _leave function for all
            # nodes which have depth &lt;= node 4
            #
            #             ---
            #            | 1 |
            #             ---
            #            /   \
            #          ---    ---
            #         | 2 |  | 4 |
            #          ---    ---
            #         /
            #       ---
            #      | 3 |
            #       ---

            self.visit_leave_queue.put(prev_node)
            while not self.visit_leave_queue.empty():
                self.node_to_lint = self.visit_leave_queue.get()
                self.lint_node(RuleType.Leave)

                if self.node_to_lint.depth == node.depth:
                    break

            self.visit_leave_queue.put(node)
            self.node_to_lint = node
            self.lint_node(RuleType.Visit)

        else:
            ProgramReporter.show_error_message(
                message=&#34;Unexpected error during evaluating rules.&#34;,
                exit_code=ExitWith.InternalError
            )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sql_code_analyzer.visitor" href="index.html">sql_code_analyzer.visitor</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sql_code_analyzer.visitor.rules_visitor.RuleType" href="#sql_code_analyzer.visitor.rules_visitor.RuleType">RuleType</a></code></h4>
<ul class="">
<li><code><a title="sql_code_analyzer.visitor.rules_visitor.RuleType.Leave" href="#sql_code_analyzer.visitor.rules_visitor.RuleType.Leave">Leave</a></code></li>
<li><code><a title="sql_code_analyzer.visitor.rules_visitor.RuleType.Visit" href="#sql_code_analyzer.visitor.rules_visitor.RuleType.Visit">Visit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sql_code_analyzer.visitor.rules_visitor.RulesVisitor" href="#sql_code_analyzer.visitor.rules_visitor.RulesVisitor">RulesVisitor</a></code></h4>
<ul class="">
<li><code><a title="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.apply_rules" href="#sql_code_analyzer.visitor.rules_visitor.RulesVisitor.apply_rules">apply_rules</a></code></li>
<li><code><a title="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.call_rule" href="#sql_code_analyzer.visitor.rules_visitor.RulesVisitor.call_rule">call_rule</a></code></li>
<li><code><a title="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.clear_lint_variables" href="#sql_code_analyzer.visitor.rules_visitor.RulesVisitor.clear_lint_variables">clear_lint_variables</a></code></li>
<li><code><a title="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.expect_set" href="#sql_code_analyzer.visitor.rules_visitor.RulesVisitor.expect_set">expect_set</a></code></li>
<li><code><a title="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.get_rules" href="#sql_code_analyzer.visitor.rules_visitor.RulesVisitor.get_rules">get_rules</a></code></li>
<li><code><a title="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.lint_node" href="#sql_code_analyzer.visitor.rules_visitor.RulesVisitor.lint_node">lint_node</a></code></li>
<li><code><a title="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.node" href="#sql_code_analyzer.visitor.rules_visitor.RulesVisitor.node">node</a></code></li>
<li><code><a title="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.node_to_lint" href="#sql_code_analyzer.visitor.rules_visitor.RulesVisitor.node_to_lint">node_to_lint</a></code></li>
<li><code><a title="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.normal_rules" href="#sql_code_analyzer.visitor.rules_visitor.RulesVisitor.normal_rules">normal_rules</a></code></li>
<li><code><a title="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.persistent_rules" href="#sql_code_analyzer.visitor.rules_visitor.RulesVisitor.persistent_rules">persistent_rules</a></code></li>
<li><code><a title="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.register_rule" href="#sql_code_analyzer.visitor.rules_visitor.RulesVisitor.register_rule">register_rule</a></code></li>
<li><code><a title="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.reports" href="#sql_code_analyzer.visitor.rules_visitor.RulesVisitor.reports">reports</a></code></li>
<li><code><a title="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.restrict_rules" href="#sql_code_analyzer.visitor.rules_visitor.RulesVisitor.restrict_rules">restrict_rules</a></code></li>
<li><code><a title="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.rules" href="#sql_code_analyzer.visitor.rules_visitor.RulesVisitor.rules">rules</a></code></li>
<li><code><a title="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.rules_args_data" href="#sql_code_analyzer.visitor.rules_visitor.RulesVisitor.rules_args_data">rules_args_data</a></code></li>
<li><code><a title="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.save_reports" href="#sql_code_analyzer.visitor.rules_visitor.RulesVisitor.save_reports">save_reports</a></code></li>
<li><code><a title="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.temporary_rules" href="#sql_code_analyzer.visitor.rules_visitor.RulesVisitor.temporary_rules">temporary_rules</a></code></li>
<li><code><a title="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.traversing_ast_done" href="#sql_code_analyzer.visitor.rules_visitor.RulesVisitor.traversing_ast_done">traversing_ast_done</a></code></li>
<li><code><a title="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.visit" href="#sql_code_analyzer.visitor.rules_visitor.RulesVisitor.visit">visit</a></code></li>
<li><code><a title="sql_code_analyzer.visitor.rules_visitor.RulesVisitor.visit_leave_queue" href="#sql_code_analyzer.visitor.rules_visitor.RulesVisitor.visit_leave_queue">visit_leave_queue</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>