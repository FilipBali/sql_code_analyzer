from typing import List
import textwrap

from sql_code_analyzer.adapter.freature_class.base_cast import BaseCast
from sql_code_analyzer.in_memory_representation.struct.base import Base
from sql_code_analyzer.output.enums import OutputType
from sql_code_analyzer.output.reporter.base import Reporter, _Message
from sql_code_analyzer.output.reporter.program_reporter import ProgramReporter


class RuleReport(_Message):
    """
    Class of rule report which encapsulates the report generated by the rule.
    """

    def __init__(self,
                 rule_name,
                 message,
                 node):
        """
        Generate rule report object
        :param rule_name: Rule name defined by rule.
        :param message: Rule message defined by rule.
        :param node: The specific node where the message is created.
        """

        self.rule_name = rule_name
        self.message = message
        self.node = node

    def _create_message(self, message: str, color: str = "\033[0m"):
        return color + message + self._color["reset"] + " "

    def _wrap_message(self, message: str, subsequent_indent: int):
        return '\n'.join(textwrap.wrap(message, self._wrap_length, subsequent_indent=' ' * subsequent_indent))

    def print(self, statement):

        # statement = statement.split("\n")

        lines = statement.split("\n")
        result = []
        for line in lines:
            if "--" in line:
                text, index = line.split("--")
                result.append((text, int(index)))

        statement = result

        line = "_ "
        col = "_ "
        length = 0
        code_preview = ""
        code_arrow = ""
        if self.node.code_location is not None:
            line = str(self.node.code_location[0]["line"])
            col = str(self.node.code_location[0]["col"])

            same_line = int(line)
            # If multiple tokens
            for token in self.node.code_location:
                if token["line"] != same_line:
                    length = len(str(self.node.code_location[0]["text"]))
                    break

                length += len(str(token["text"]))

            length -= 1

            value = "".join([x[0] for x in statement if x[1] == int(line)])

            leading_spaces = len(value) - len(value.lstrip())
            code_preview = line.rjust(4, " ") + " | " + (value.lstrip())

            arrow = (" " * (int(col)-1-leading_spaces) + "^" + "~" * length)

            code_arrow = self._create_message(
                message=" " * len(line.rjust(4, " ") + " | ") + arrow,
                color=self._color["red"]
            )

        location = self._create_message(message="L: " + line + " C: " + col, color=self._color["green"])
        arrow = self._create_message(message=" --> ")
        rule_name = self._create_message(message="[" + self.rule_name + "]", color=self._color["red"])
        nl = "\n"
        spaces = "Report: "
        message = self._create_message(message=self.message)

        if self.node.code_location is not None:
            this_report = location + arrow + rule_name + nl + \
                spaces + message + 2 * nl + \
                code_preview + nl + \
                code_arrow + nl

        else:
            this_report = location + arrow + rule_name + nl + \
                spaces + message + 2 * nl

        self.text = this_report
        super().print()

    @staticmethod
    def _verify_code_location(node) -> bool:
        if hasattr(node, "code_location"):
            if node.code_location is not None:
                return True

        return False

    def validate(self) -> bool:
        try:
            self._validate_report_data()
        except (Exception, ) as e:
            return False

        return True

    def _validate_report_data(self) -> None:
        """
        Verify if all necessary class properties are set.
        :return: None
        """

        if not isinstance(self.rule_name, str):
            ProgramReporter.show_type_integrity_warning_message(
                message="Rule name must be string!"
            )
            raise "Rule name must be string!"

        if not isinstance(self.message, str):
            ProgramReporter.show_type_integrity_warning_message(
                message="Rule message must be string!"
            )
            raise "Rule message must be string!"

        if not issubclass(type(self.node), BaseCast):
            ProgramReporter.show_type_integrity_warning_message(
                message="The node must be node of abstract syntax tree."
            )
            raise "The node must be node of abstract syntax tree."


class RuleReporter(Reporter):
    """
    Class which provides a way of reporting rule reports to user.
    """

    def __init__(self):
        self.reports = []
        self.mem_rep_reports = []
        self.statement: str = ""
        Base.RuleReporter = self

    def add_reports(self, reports: List[RuleReport]):

        for report in reports:
            report: RuleReport
            self.reports.append((self.statement, report))

    def print_reports(self):
        statement_change = ""
        group_by_statements: List = []

        # Group statements and their reports by statement
        for statement_t, report in self.reports:

            statement = statement_t[0]
            position = statement_t[1]

            # Delete empty lines from statement string
            # For a more compact visualization of the output,
            # it is better to delete the line that does not contain the code
            long_string = statement
            lines = long_string.split("\n")
            result = ""
            for line in lines:
                if line.lstrip().find("--") > 0:
                    result += line + "\n"
            statement = result

            if statement_change != statement:
                statement_tuple = (statement, [], position)
                _, statement_reports, _ = statement_tuple
                group_by_statements.append(statement_tuple)
                statement_change = statement

            else:
                _, statement_reports, _ = group_by_statements[-1]

            statement_reports.append(report)

        for statement, statement_reports , _ in group_by_statements:
            # Print header
            if ProgramReporter.verbose >= 1:
                self._print_statement_output_header(statement)

            with_loc: List = []
            without_loc: List = []
            mem_rep: List = []

            # Divide messages into those with and without location
            for statement_report in statement_reports:
                if isinstance(statement_report, str):
                    mem_rep.append(statement_report)
                    continue

                if statement_report.node.code_location is not None:
                    with_loc.append(statement_report)
                else:
                    without_loc.append(statement_report)

            # Sort reports by line
            with_loc.sort(key=lambda x: x.node.code_location[0]['line'])

            # Print reports with location
            for statement_report in with_loc:
                statement_report: RuleReport
                statement_report.print(statement=statement)

            # Print reports with no location
            for statement_report in without_loc:
                statement_report: RuleReport
                statement_report.print(statement=statement)

            for statement_report in mem_rep:
                statement_report: str
                ProgramReporter.show_warning_message(message=statement_report)

    def _print_statement_output_header(self, statement):
        header = "" + \
        "//=============================================\\\\\n"  + \
        "||           LINTING RESULT OF STATEMENT       ||\n"  + \
        "\\\\=============================================//\n"  + \
        f"{statement}\n"  + \
        "\\\\=============================================//\n"

        self.text = header
        super().print()

    def add_memory_representation_report(self, message):
        self.reports.append((self.statement, message))
