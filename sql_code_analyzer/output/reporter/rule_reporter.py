from typing import List
import textwrap

from sql_code_analyzer.adapter.freature_class.base_cast import BaseCast
from sql_code_analyzer.in_memory_representation.struct.base import Base
from sql_code_analyzer.output.reporter.base import Reporter, _Message
from sql_code_analyzer.output.reporter.program_reporter import ProgramReporter


class RuleReport(_Message):
    """
    Class of rule report which encapsulates the report generated by the rule.
    """

    def __init__(self,
                 rule_name,
                 message,
                 node,
                 rule_class_name,
                 rule_class_filename,
                 code_preview: bool,
                 underline_entire_line,
                 statement=None):
        """
        Generate rule report object
        :param rule_name: Rule name defined by rule.
        :param message: Rule message defined by rule.
        :param node: The specific node where the message is created.
        :param rule_class_name: Name of class of rule
        :param rule_class_filename: Name of file where is rule stored
        :param code_preview: If the code has to be displayed.
        :param statement: SQL statement
        """

        self.rule_name = rule_name
        self.message = message
        self.node = node
        self.rule_class_name = rule_class_name
        self.rule_class_filename = rule_class_filename
        self.code_preview = code_preview
        self.statement = statement
        self.underline_entire_line = underline_entire_line

    def set_statement(self, statement):
        self.statement = statement

    def _create_message(self, message: str, color: str = "\033[0m"):
        return color + message + self._color["reset"] + " "

    def print(self):
        statement = self.statement[0]

        lines = statement.split("\n")
        result = []
        for line in lines:
            if "--" in line:
                text, index = line.split("--")
                result.append((text, int(index)))

        statement = result

        line = "_ "
        col = "_ "
        length = 0
        code_preview = ""
        code_arrow = ""
        if self.node.code_location is not None:
            line = str(self.node.code_location[0]["line"])
            col = str(self.node.code_location[0]["col"])

            same_line = int(line)
            # If multiple tokens
            for token in self.node.code_location:
                if token["line"] != same_line:
                    length = len(str(self.node.code_location[0]["text"]))
                    break

                length += len(str(token["text"]))

            length -= 1

            value = "".join([x[0] for x in statement if x[1] == int(line)])

            leading_spaces = len(value) - len(value.lstrip())
            code_preview = line.rjust(4, " ") + " | " + (value.lstrip())

            if self.underline_entire_line:
                arrow = ("^" + "~" * (len(value.lstrip())-2))
            else:
                arrow = (" " * (int(col)-1-leading_spaces) + "^" + "~" * length)

            code_arrow = self._create_message(
                message=" " * len(line.rjust(4, " ") + " | ") + arrow,
                color=self._color["red"]
            )

        location = self._create_message(message="L: " + line + " C: " + col, color=self._color["green"])
        arrow = self._create_message(message=" --> ")
        rule_name = self._create_message(message="[" + self.rule_name + "]", color=self._color["red"])
        nl = "\n"
        spaces = "Report: "
        message = self._create_message(message=self.message)

        rule_details = f"Rule class: {self.rule_class_name}\nRule file: {self.rule_class_filename}\n"

        if not self.code_preview:
            if ProgramReporter.verbose < 2:
                rule_details = ""

            this_report = location + arrow + rule_name + nl + \
                rule_details + \
                spaces + message + nl

        elif self.node.code_location is not None:
            if ProgramReporter.verbose < 2:
                rule_details = ""

            this_report = location + arrow + rule_name + nl + \
                rule_details + \
                spaces + message + 2 * nl + \
                code_preview + nl + \
                code_arrow + nl

        else:
            if ProgramReporter.verbose < 2:
                rule_details = ""

            this_report = location + arrow + rule_name + nl + \
                rule_details + \
                spaces + message + 2 * nl

        self.text = this_report
        super().print()

    @staticmethod
    def _verify_code_location(node) -> bool:
        if hasattr(node, "code_location"):
            if node.code_location is not None:
                return True

        return False

    def validate(self) -> bool:
        try:
            self._validate_report_data()
        except (Exception, ) as e:
            return False

        return True

    def _validate_report_data(self) -> None:
        """
        Verify if all necessary class properties are set.
        :return: None
        """

        if not isinstance(self.rule_name, str):
            ProgramReporter.show_type_integrity_warning_message(
                message="Rule name must be string!"
            )
            raise "Rule name must be string!"

        if not isinstance(self.message, str):
            ProgramReporter.show_type_integrity_warning_message(
                message="Rule message must be string!"
            )
            raise "Rule message must be string!"

        if not issubclass(type(self.node), BaseCast):
            ProgramReporter.show_type_integrity_warning_message(
                message="The node must be node of abstract syntax tree."
            )
            raise "The node must be node of abstract syntax tree."


class RuleReporter(Reporter):
    """
    Class which provides a way of reporting rule reports to user.
    """

    def __init__(self):
        self.reports = []
        self.mem_rep_reports = []
        self.statement: str = ""
        Base._rule_reporter = self

    def add_reports(self, reports: List[RuleReport]):

        for report in reports:
            report: RuleReport

            if report.statement is None:
                report.set_statement(statement=self.statement)

            # In tuple:
            # First parameter stores data about statement to which report belongs to
            # Second parameter stores report data
            self.reports.append((report.statement, report))

    def print(self):
        statement_change = ""
        group_by_statements: List = []

        # Group statements and their reports by statement
        for statement_t, report in self.reports:

            statement = statement_t[0]
            position = statement_t[1]

            # Delete empty lines from statement string
            # For a more compact visualization of the output,
            # it is better to delete the line that does not contain the code
            result = ""
            for line in statement.split("\n"):
                if line.lstrip().find("--") > 0:
                    result += line + "\n"
            statement = result

            if statement_change != statement:
                statement_tuple = (statement, [], position)
                _, statement_reports, _ = statement_tuple
                group_by_statements.append(statement_tuple)
                statement_change = statement

            else:
                _, statement_reports, _ = group_by_statements[-1]

            statement_reports.append(report)

        for statement, statement_reports , _ in group_by_statements:
            # Print header
            if ProgramReporter.verbose >= 1:
                self._print_statement_output_header(statement)

            with_loc: List = []
            without_loc: List = []
            mem_rep: List = []
            no_code_preview: List = []

            # Divide messages into those with and without location
            for statement_report in statement_reports:
                if isinstance(statement_report, str):
                    mem_rep.append(statement_report)
                    continue

                if not statement_report.code_preview:
                    no_code_preview.append(statement_report)
                    continue

                if statement_report.node.code_location is not None:
                    with_loc.append(statement_report)
                else:
                    without_loc.append(statement_report)

            # Sort reports by line
            with_loc.sort(key=lambda x: x.node.code_location[0]['line'])

            # Print reports with location
            for statement_report in with_loc:
                statement_report: RuleReport
                statement_report.print()

            if len(without_loc):
                print("Messages that could not be linked to the code")

                # Print reports with no location
                for statement_report in without_loc:
                    statement_report: RuleReport
                    statement_report.print()

            if len(no_code_preview):
                print("Messages for which no code preview is required:")

                for statement_report in no_code_preview:
                    statement_report: RuleReport
                    statement_report.print()

            if len(mem_rep):
                print("Additional context analysis:")

                for context_report in mem_rep:
                    ProgramReporter.show_memory_representation_message(message=context_report)

    def _print_statement_output_header(self, statement):
        header = "" + \
        "//=============================================\\\\\n"  + \
        "||           LINTING RESULT OF STATEMENT       ||\n"  + \
        "\\\\=============================================//\n"  + \
        f"{statement}\n"  + \
        "\\\\=============================================//\n"

        self.text = header
        super().print()

    def add_memory_representation_report(self, message):
        self.reports.append((self.statement, message))
