from typing import List
import textwrap

from sql_code_analyzer.adapter.freature_class.base_cast import BaseCast
from sql_code_analyzer.output.reporter.base import Reporter, _Message
from sql_code_analyzer.output.reporter.program_reporter import ProgramReporter


class RuleReport(_Message):
    """
    Class of rule report which encapsulates the report generated by the rule.
    """

    _color = {"reset": "\033[0m",
              "green": "\33[92m",
              "red": "\33[91m"
              }

    _wrap_length = 80

    def __init__(self,
                 rule_id,
                 rule_name,
                 message,
                 node):
        """
        Generate rule report object
        :param rule_id: Rule ID defined by rule.
        :param rule_name: Rule name defined by rule.
        :param message: Rule message defined by rule.
        :param node: The specific node where the message is created.
        """

        self.rule_id = rule_id
        self.rule_name = rule_name
        self.message = message
        self.node = node

        self._validate_report_data()

    def _create_message(self, message: str, color: str = "\033[0m"):
        return color + message + self._color["reset"] + " "

    @staticmethod
    def _vertical_line():
        return " | "

    def _straighten_message_l(self, message: str, length: int):
        return message.ljust(length, " ")

    def _straighten_message_r(self, message: str, length: int):
        return message.rjust(length, " ")

    def _wrap_message(self, message: str, subsequent_indent: int):
        return '\n'.join(textwrap.wrap(message, self._wrap_length, subsequent_indent=' ' * subsequent_indent))

    def print(self, statement):

        statement = statement.split("\n")

        line = "_ "
        col = "_ "
        code_preview = ""
        code_arrow = ""
        if self.node.code_location is not None:
            line = str(self.node.code_location[0]["line"])
            col = str(self.node.code_location[0]["col"])

            leading_spaces = len(statement[int(line)-1]) - len(statement[int(line)-1].lstrip())
            code_preview = line.rjust(4, " ") + " | " + (statement[int(line)-1].lstrip())
            code_arrow = self._create_message(
                message=" " * len(line.rjust(4, " ") + " | ") + (" " * (int(col)-1-leading_spaces) + "^"),
                color=self._color["red"]
            )

        location = self._create_message(message="L: " + line + " C: " + col, color=self._color["green"])
        arrow = self._create_message(message=" --> ")
        rule_name = self._create_message(message="[" + self.rule_name + "]", color=self._color["red"])
        nl = "\n"
        spaces = "Report: "
        message = self._create_message(message=self.message)

        if self.node.code_location is not None:
            this_report = location + arrow + rule_name + nl + \
                spaces + message + 2 * nl + \
                code_preview + nl + \
                code_arrow + nl

        else:
            this_report = location + arrow + rule_name + nl + \
                spaces + message + 2 * nl

        print(this_report)

    @staticmethod
    def _verify_code_location(node) -> bool:
        if hasattr(node, "code_location"):
            if node.code_location is not None:
                return True

        return False

    def _validate_report_data(self) -> None:
        """
        Verify if all necessary class properties are set.
        :return: None
        """

        # TODO implements report deletion if the requirements are not met.

        if not isinstance(self.rule_id, str):
            ProgramReporter.show_type_integrity_warning_message(
                message="Rule ID must be string!"
            )

        if not isinstance(self.rule_name, str):
            ProgramReporter.show_type_integrity_warning_message(
                message="Rule name must be string!"
            )

        if not isinstance(self.message, str):
            ProgramReporter.show_type_integrity_warning_message(
                message="Rule message must be string!"
            )

        if not issubclass(type(self.node), BaseCast):
            ProgramReporter.show_type_integrity_warning_message(
                message="The node must be node of abstract syntax tree."
            )


class RuleReporter(Reporter):
    """
    Class which provides a way of reporting rule reports to user.
    """

    def __init__(self):
        self.reports = []

    def add_reports(self, statement, reports: List[RuleReport]):

        for report in reports:
            report: RuleReport
            self.reports.append((statement, report))

    def print_reports(self):
        statement_change = ""
        for statement, report in self.reports:
            if statement_change != statement:
                print("//=============================================\\\\")
                print("||           LINTING RESULT OF STATEMENT       ||")
                print("\\\\=============================================//")
                print(statement)
                print("\\\\=============================================//")
                statement_change = statement

            report: RuleReport
            report.print(statement=statement)
